---
title: "Declining Access to Gynecologic Oncology Care: Analysis of Trends and Disparities, 2013-2022"
author:
  - name: "Tyler Muffly, MD"
    affiliation: "Denver Health"
    email: "tyler.muffly@dhha.org"
    corresponding: true
  - name: "Andrew Tannous, MD"
    affiliation: "St. Joseph's"
date: "`r format(Sys.Date(), '%B %d, %Y')`"
keywords: [gynecologic oncology, healthcare disparities, geographic accessibility, cancer care equity, drive time analysis, racial disparities, temporal trends, healthcare workforce]
output:
  html_document:
    theme: cosmo
    highlight: tango
    toc: true
    toc_depth: 3
    toc_float: 
      collapsed: false
      smooth_scroll: true
    number_sections: true
    code_folding: hide
    df_print: paged
    fig_caption: true
    fig_height: 6
    fig_width: 10
editor_options: 
  chunk_output_type: console
---

# OVERVIEW
This code performs a comprehensive analysis of access to gynecologic oncologists (GOs) across different geographic regions, time periods, and demographic groups. The analysis focuses on drive time thresholds (30, 60, 120, and 180 minutes) to measure accessibility. The code includes several robust functions that process data from CSV files, calculate weighted statistics, analyze temporal trends, and examine racial/ethnic disparities in access. It then creates detailed visualizations showing accessibility patterns, including time series analysis of declining access rates, comparisons between different years (particularly 2013 vs 2022), normalized trend analysis, and demographic breakdowns. The visualizations reveal a consistent decline in accessibility across all drive time thresholds from 2013 to 2022, with the decline being most pronounced for shorter travel times (30-minute threshold). The code also generates formatted results text and publication-ready tables that highlight key findings about geographic and racial/ethnic disparities in access to gynecologic oncology care.

# Setup
```{r setup, include=FALSE}
library(tidyverse)
library(logger)
library(assertthat)
library(tidyverse)
library(ggplot2)
library(scales)
library(viridis)
library(gghighlight)
library(glue)
library(flexdashboard)
library(DT)
library(knitr)
library(ggrepel)
library(patchwork)
library(ggtext)
library(glue)
library(DT)
library(kableExtra)
library(tidyr)
library(scales)
```

```{r knitr options}
knitr::opts_chunk$set(
  echo = TRUE,          # Show code in output
  warning = FALSE,      # No warnings
  message = TRUE,       # Show messages
  error = FALSE,        # Don't stop on errors
  fig.width = 8,        # Default figure width
  fig.height = 6,       # Default figure height
  fig.align = "center", # Center figures
  dpi = 300,            # Higher resolution figures
  out.width = "85%",    # Control display size
  cache = FALSE,        # Cache results? (TRUE for large computations)
  comment = "#>",       # Comment character for output
  tidy = FALSE,         # Don't reformat code
  dev = "png",           # Output device for plots
  include = FALSE
)
```


```{r calculate_group_stats}
# This function helps us find the average and spread (like how different the numbers are) of a group of percentages, but it gives more importance to some numbers than others, based on how big their group is. So if one group has more people, it counts more in the average. It tells us two things: the weighted average and how much the numbers vary around that average.

# Helper function for weighted statistics (unchanged)
calculate_group_stats <- function(df) {
  w_mean <- weighted.mean(df$percent, df$total)
  w_var <- sum(df$total * (df$percent - w_mean)^2) / sum(df$total)
  w_sd <- sqrt(w_var)
  
  return(tibble(
    weighted_mean = w_mean,
    weighted_sd = w_sd
  ))
}
```

```{r functions}
#' Analysis of Access to Gynecologic Oncologists
#' 
#' @importFrom dplyr %>% group_by summarize filter mutate arrange desc n
#' @importFrom tidyr pivot_wider
#' @importFrom stats sd weighted.mean
#' @importFrom assertthat assert_that

# Helper function for calculating weighted statistics
#' @noRd
calculate_weighted_stats <- function(data, value_col, weight_col) {
  assert_that(is.data.frame(data))
  
  weighted_mean <- weighted.mean(data[[value_col]], data[[weight_col]])
  
  # Calculate weighted variance
  weighted_var <- sum(data[[weight_col]] * (data[[value_col]] - weighted_mean)^2) / 
                 sum(data[[weight_col]])
  
  weighted_sd <- sqrt(weighted_var)
  
  return(list(mean = weighted_mean, sd = weighted_sd))
}

#' Analyze drive time access trends
#' @noRd
analyze_drive_time_trends <- function(data) {
  logger::log_info("Analyzing drive time trends...")
  
  yearly_stats <- data %>%
    dplyr::filter(category == "total_female") %>%
    dplyr::group_by(year) %>%
    dplyr::summarize(
      access_stats = list(calculate_weighted_stats(cur_data(), "percent", "total")),
      mean_access = access_stats[[1]]$mean,
      sd_access = access_stats[[1]]$sd,
      .groups = "drop"
    )
  
  logger::log_info("Drive time analysis complete")
  return(yearly_stats)
}

#' Analyze geographic access disparities
#' @noRd
analyze_geographic_disparities <- function(data) {
  logger::log_info("Analyzing geographic disparities...")
  
  low_access_pop <- data %>%
    dplyr::filter(range > 3600, category == "total_female") %>%
    dplyr::group_by(year) %>%
    dplyr::summarize(
      low_access_population = sum(count) / 1e6,  # Convert to millions
      .groups = "drop"
    )
  
  logger::log_info("Geographic disparities analysis complete")
  return(low_access_pop)
}

#' Analyze racial and ethnic disparities
#' @noRd
analyze_racial_disparities <- function(data, target_year = 2015) {
  logger::log_info("Analyzing racial disparities for year {target_year}...")
  
  racial_stats <- data %>%
    dplyr::filter(
      year == target_year,
      range == 3600,
      category != "total_female"
    ) %>%
    dplyr::group_by(category) %>%
    dplyr::summarize(
      access_stats = list(calculate_weighted_stats(cur_data(), "percent", "total")),
      mean_access = access_stats[[1]]$mean,
      sd_access = access_stats[[1]]$sd,
      .groups = "drop"
    ) %>%
    dplyr::arrange(dplyr::desc(mean_access))
  
  logger::log_info("Racial disparities analysis complete")
  return(racial_stats)
}

#' Main analysis function
#' @param data_path Path to the CSV file
#' @return List containing analysis results
#' @examples
#' results <- analyze_go_access("access_by_group.csv")
analyze_go_access <- function(data_path) {
  logger::log_info("Starting analysis of GO access data")
  
  # Read and validate data
  assert_that(file.exists(data_path))
  data <- readr::read_csv(data_path, show_col_types = FALSE)
  
  # Perform analyses
  drive_time_trends <- analyze_drive_time_trends(data)
  geographic_disparities <- analyze_geographic_disparities(data)
  racial_disparities_2015 <- analyze_racial_disparities(data, 2015)
  
  # Generate summary text
  results <- list(
    drive_time = drive_time_trends,
    geographic = geographic_disparities,
    racial = racial_disparities_2015
  )
  
  # Print key findings
  cat("\nDrive Time Analysis Results:\n")
  cat(sprintf("2013 Access Rate: %.2f%% ± %.2f%%\n", 
              drive_time_trends$mean_access[1], 
              drive_time_trends$sd_access[1]))
  cat(sprintf("2022 Access Rate: %.2f%% ± %.2f%%\n", 
              drive_time_trends$mean_access[nrow(drive_time_trends)], 
              drive_time_trends$sd_access[nrow(drive_time_trends)]))
  
  cat("\nGeographic Disparities:\n")
  cat(sprintf("Low-access population 2022: %.1f million\n", 
              geographic_disparities$low_access_population[nrow(geographic_disparities)]))
  
  cat("\nRacial/Ethnic Disparities (2015):\n")
  racial_disparities_2015 %>%
    dplyr::mutate(
      category = stringr::str_remove(category, "total_female_"),
      category = stringr::str_to_upper(category)
    ) %>%
    dplyr::arrange(dplyr::desc(mean_access)) %>%
    print()
  
  logger::log_info("Analysis complete")
  return(results)
}

# Example usage:
# library(tidyverse)
# library(logger)
# results <- analyze_go_access("access_by_group.csv")
```

## What is a Census Tract?
```{r, include = FALSE}
# Enhanced Multi-scale Census Tract Visualization
# This script creates an improved multi-scale view of US census tracts

# Load required packages
library(tigris)      # For Census geography
library(sf)          # For spatial data handling
library(ggplot2)     # For visualization
library(dplyr)       # For data manipulation
library(patchwork)   # For combining plots
library(viridis)     # For color palettes
library(ggspatial)   # For scale bars and north arrows

# Set tigris options
options(tigris_use_cache = TRUE, tigris_class = "sf")

# Set theme for all maps
map_theme <- theme_minimal() +
  theme(
    plot.title = element_text(size = 14, face = "bold"),
    plot.subtitle = element_text(size = 11),
    legend.position = "bottom",
    legend.title = element_text(size = 10),
    legend.text = element_text(size = 9),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.text = element_blank(),
    axis.title = element_blank(),
    plot.background = element_rect(fill = "white", color = NA),
    panel.background = element_rect(fill = "white", color = NA)
  )

# Function to create enhanced multi-scale visualization
# Function to create enhanced multi-scale visualization with larger text
create_enhanced_multiscale_viz <- function() {
  # Define the map theme with LARGER text sizes
  map_theme <- theme_minimal() +
    theme(
      # Larger text for all elements
      text = element_text(size = 14),
      # Larger, bolder titles
      plot.title = element_text(size = 20, face = "bold", hjust = 0.5),
      plot.subtitle = element_text(size = 16, hjust = 0.5),
      # Remove grid lines
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      # Larger axis text
      axis.text = element_text(size = 12),
      axis.title = element_blank(),
      # Larger legend
      legend.title = element_text(size = 14, face = "bold"),
      legend.text = element_text(size = 12),
      legend.position = "bottom",
      # Larger strip text for facets
      strip.text = element_text(size = 14, face = "bold")
    )
  
  # Get base geometries
  states <- states(cb = TRUE, resolution = "20m")
  co <- states %>% filter(STUSPS == "CO")
  state_boundaries <- st_union(states)
  
  co_counties <- counties(state = "08", cb = TRUE)
  co_tracts <- tracts(state = "08", cb = TRUE)
  
  # Denver metro counties
  denver_counties_fips <- c("031", "005", "059", "001", "035") # Denver, Arapahoe, Jefferson, Adams, Douglas
  denver_counties <- co_counties %>%
    filter(COUNTYFP %in% denver_counties_fips)
  
  # Calculate county centroids for labels
  denver_county_centers <- st_centroid(denver_counties)
  
  denver_tracts <- tracts(state = "08", county = denver_counties_fips, cb = TRUE)
  
  # Get major cities for context
  co_places <- places(state = "08", cb = TRUE) %>%
    filter(NAME %in% c("Denver", "Colorado Springs", "Aurora", "Fort Collins", "Boulder", "Pueblo"))
  
  # 1. NATIONAL VIEW WITH IMPROVED STYLING AND LARGER TEXT
  national <- ggplot() +
    # Base US with light gray fill
    geom_sf(data = states, fill = "#f5f5f5", color = "#cccccc", size = 0.2) +
    # Country outline
    geom_sf(data = state_boundaries, fill = NA, color = "#888888", size = 0.5) +
    # Highlight Colorado
    geom_sf(data = co, fill = "#4e73df", color = "#000000", size = 0.5, alpha = 0.7) +
    # Add state labels - INCREASED SIZE from 3 to 5
    geom_sf_text(data = states %>% filter(STUSPS == "CO"), aes(label = STUSPS), 
                 color = "white", fontface = "bold", size = 5) +
    # Set boundaries to ensure Alaska and Hawaii are shown
    coord_sf(crs = st_crs(states), xlim = c(-125, -65), ylim = c(25, 50)) +
    # Add title
    labs(title = "National View",
         subtitle = "Colorado highlighted") +
    # Apply theme
    map_theme

  # 2. COLORADO VIEW WITH COUNTY BOUNDARIES AND CITIES - LARGER TEXT
  state <- ggplot() +
    # Census tracts with very light fill
    geom_sf(data = co_tracts, fill = "#f8f8f8", color = "#e5e5e5", size = 0.05) +
    # County boundaries
    geom_sf(data = co_counties, fill = NA, color = "#888888", size = 0.3) +
    # Highlight Denver metro area
    geom_sf(data = denver_counties, fill = "#4e73df", color = "#000000", size = 0.5, alpha = 0.3) +
    # Add major cities
    geom_sf(data = co_places, color = "#e74a3b", size = 3) + # Increased from 2 to 3
    # Add city labels - INCREASED SIZE from 2.5 to 4
    geom_sf_text(data = co_places, aes(label = NAME), nudge_y = 0.05, 
                 color = "#e74a3b", fontface = "bold", size = 4) +
    # Add Colorado state boundary
    geom_sf(data = co, fill = NA, color = "#000000", size = 0.8) +
    # Scale bar
    annotation_scale(location = "bl", width_hint = 0.2, 
                     text_cex = 1.2) + # Increased text size
    # Add north arrow
    annotation_north_arrow(location = "tr", which_north = "true", 
                          style = north_arrow_minimal, 
                          height = unit(1.0, "cm"), width = unit(1.0, "cm")) + # Larger arrow
    # Add title
    labs(title = "Colorado View",
         subtitle = "Denver metro area highlighted") +
    # Apply theme
    map_theme

  # 3. DENVER METRO VIEW WITH DETAILED CENSUS TRACTS - LARGER TEXT
  metro <- ggplot() +
    # Census tracts with white fill and light gray borders
    geom_sf(data = denver_tracts, fill = "#ffffff", color = "#cccccc", size = 0.1) +
    # County boundaries
    geom_sf(data = denver_counties, fill = NA, color = "#888888", size = 0.5) +
    # Add major cities
    geom_sf(data = co_places %>% filter(NAME %in% c("Denver", "Aurora")), 
            color = "#e74a3b", size = 3) + # Increased from 2 to 3
    # Add city labels - INCREASED SIZE from 3 to 5
    geom_sf_text(data = co_places %>% filter(NAME %in% c("Denver", "Aurora")), 
                aes(label = NAME), nudge_y = 0.01, 
                color = "#e74a3b", fontface = "bold", size = 5) +
    # Add county labels - INCREASED SIZE from 2.5 to 4
    geom_sf_label(data = denver_county_centers, 
                 aes(label = NAME), 
                 size = 4, 
                 fill = alpha("white", 0.8), 
                 color = "#333333",
                 label.padding = unit(0.3, "lines"), # Increased padding
                 label.r = unit(0.15, "lines")) +
    # Scale bar - Larger text
    annotation_scale(location = "bl", width_hint = 0.2, 
                     text_cex = 1.2) +
    # Add north arrow - Larger arrow
    annotation_north_arrow(location = "tr", which_north = "true", 
                          style = north_arrow_minimal, 
                          height = unit(1.0, "cm"), width = unit(1.0, "cm")) +
    # Add title
    labs(title = "Denver Metro View",
         subtitle = "Detailed census tracts with county boundaries") +
    # Apply theme
    map_theme

  # 4. CREATE A SAMPLE CHOROPLETH WITH SIMULATED ACCESS DATA - LARGER TEXT
  # Simulate access data (this would be replaced with your actual data)
  set.seed(123)
  denver_tracts$access_rate <- sample(
    c(20:90), 
    size = nrow(denver_tracts), 
    replace = TRUE, 
    prob = c(rep(0.5, 20), rep(1, 20), rep(2, 15), rep(1.5, 16))
  )
  
  # Create choropleth
  choropleth <- ggplot() +
    # Census tracts with access rate fill
    geom_sf(data = denver_tracts, aes(fill = access_rate), color = NA) +
    # Add county boundaries
    geom_sf(data = denver_counties, fill = NA, color = "#333333", size = 0.3) +
    # Add color scale with LARGER legend text
    scale_fill_viridis_c(
      option = "plasma",
      name = "Access Rate (%)",
      limits = c(20, 90),
      breaks = seq(20, 90, by = 10),
      guide = guide_colorbar(
        barwidth = 20, # Wider bar
        barheight = 0.8, # Taller bar
        title.position = "top",
        title.hjust = 0.5,
        label.theme = element_text(size = 12) # Larger legend labels
      )
    ) +
    # Add major cities
    geom_sf(data = co_places %>% filter(NAME %in% c("Denver", "Aurora")), 
            color = "black", size = 3) + # Increased from 2 to 3
    # Add city labels - INCREASED SIZE from 3 to 5
    geom_sf_text(data = co_places %>% filter(NAME %in% c("Denver", "Aurora")), 
                aes(label = NAME), nudge_y = 0.01, 
                color = "black", fontface = "bold", size = 5) +
    # Scale bar with larger text
    annotation_scale(location = "bl", width_hint = 0.2, 
                     text_cex = 1.2) +
    # Add title
    labs(title = "Denver Metro: Simulated Access Rates",
         subtitle = "Census tract level gynecologic oncology access (simulated data)") +
    # Apply theme
    map_theme

  # Combine the maps using patchwork
  layout <- "
  AB
  CD
  "
  
  combined <- national + state + metro + choropleth +
    plot_layout(design = layout) +
    plot_annotation(
      title = "Multi-scale View of Census Tracts with Access Analysis",
      subtitle = "From national overview to detailed metro area access patterns",
      caption = "Source: US Census Bureau | Simulated access data for demonstration",
      theme = theme(
        # SIGNIFICANTLY LARGER annotation text
        plot.title = element_text(size = 24, face = "bold", hjust = 0.5),
        plot.subtitle = element_text(size = 18, hjust = 0.5),
        plot.caption = element_text(size = 12, hjust = 0, face = "italic"),
        # Add margins for better spacing
        plot.margin = margin(10, 10, 10, 10)
      )
    )
  
  return(combined)
}

# Create and display the enhanced visualization
enhanced_multiscale_viz <- create_enhanced_multiscale_viz()
```

```{r, include = TRUE, fig.width = 24, fig.height = 20}
print(enhanced_multiscale_viz)

# Save the plot as a high-resolution image
ggsave("enhanced_census_tract_map.png", enhanced_multiscale_viz, 
       width = 18, height = 14, dpi = 300)
```

# ACCESS TO GYNECOLOGIC ONCOLOGY CARE: KEY TERMS

- Access Rate: Percentage of a population living within a specified drive time of a gynecologic oncologist.

- Drive Time Thresholds:
  - 30 minutes (1800 seconds)
  - 60 minutes (3600 seconds)
  - 120 minutes (7200 seconds)
  - 180 minutes (10800 seconds)

- Demographic Categories:
  - total_female: All women
  - total_female_white: White women
  - total_female_black: Black women
  - total_female_aian: American Indian/Alaska Native women
  - total_female_asian: Asian women
  - total_female_hipi: Native Hawaiian/Pacific Islander women

- Count: Number of people in each category with access
- Total: Total population in each demographic category
- Percent: Proportion with access (Count/Total × 100)

# Data Introduction

## `access_by_group.csv`
This dataset examines accessibility metrics across different demographic groups of women in the United States. The data appears to be from a study tracking access by distance and demographic characteristics.

The dataset contains 240 observations with the following variables:
- `year`: The year of observation (starting with 2013 in the visible rows)
- `range`: Distance thresholds (1800 and 3600 seconds of drive time)
- `category`: Demographic categories of women by race/ethnicity
- `count`: Number of women with access within the specified range
- `total`: Total population in that demographic category
- `percent`: Percentage with access (count/total)

The data shows significant disparities in access across racial groups. For example, at the 1800 second range in 2013, Asian women had the highest access rate (70.8%), while American Indian/Alaska Native women had the lowest (24.3%).

```{r reading access_by_group}
access_by_group <- readr::read_csv("data/Walker_data/access_by_group.csv")
```

How the percentages are calculated:

The formula is: `percent = (count / total) * 100`

Where:
- **count**: Number of women with access within the specified drive time
- **total**: Total population in that specific demographic category

For example, in row 1:
- Category: total_female
- Count: 72,362,517 (women with access within 1800 seconds/30 minutes)
- Total: 162,649,954 (total female population)
- Percent: 44.5% (72,362,517 ÷ 162,649,954 × 100)

For demographic subgroups, the denominator is the total population of that specific subgroup:

- For total_female_white (row 2): 39.1% = 46,553,359 ÷ 119,180,751 × 100
- For total_female_black (row 3): 58.9% = 12,370,992 ÷ 21,004,945 × 100
- For total_female_asian (row 5): 70.8% = 6,042,715 ÷ 8,539,880 × 100

These percentages tell you what proportion of each demographic group has access to gynecologic oncologists within the specified drive time. The denominator changes for each group to reflect the relevant total population, making the percentages comparable across different demographic categories despite their different population sizes.

This approach allows you to see disparities in access - for example, at the 1800-second (30-minute) threshold, Asian women have much higher access rates (70.8%) compared to white women (39.1%) or American Indian/Alaska Native women (24.3%).

### Data Set
```{r datatable for access_by_group, include = TRUE}
# Load required package
library(DT)

# Create the datatable with visual bars
dt <- datatable(
  data = access_by_group,
  extensions = c("Buttons", "Responsive"),
  options = list(
    dom = "Bfrtip",
    buttons = c("copy", "csv", "excel"),
    pageLength = 10,
    autoWidth = TRUE,
    scrollX = TRUE,
    columnDefs = list(list(className = "dt-center", targets = "_all"))
  ),
  filter = "top",
  rownames = FALSE,
  class = "compact stripe hover"
)

# Define max values for scaling bars
max_count <- max(access_by_group$count)
max_total <- max(access_by_group$total)

# Add formatting one step at a time, checking after each step
# Start with just the percent column
dt <- formatStyle(
  dt,
  'percent',
  background = styleColorBar(c(0, 100), '#4e73df'),
  backgroundSize = '95% 80%',
  backgroundRepeat = 'no-repeat',
  backgroundPosition = 'center'
)

# Round percent to 1 decimal
dt <- formatRound(dt, 'percent', 1)

# Add count column formatting with thousands separators
dt <- formatStyle(
  dt,
  'count',
  background = styleColorBar(c(0, max_count), '#1cc88a'),
  backgroundSize = '95% 80%',
  backgroundRepeat = 'no-repeat',
  backgroundPosition = 'center'
)
dt <- formatCurrency(dt, 'count', currency = "", interval = 3, mark = ",", digits = 0)

# Add total column formatting with thousands separators
dt <- formatStyle(
  dt,
  'total',
  background = styleColorBar(c(0, max_total), '#36b9cc'),
  backgroundSize = '95% 80%',
  backgroundRepeat = 'no-repeat',
  backgroundPosition = 'center'
)
dt <- formatCurrency(dt, 'total', currency = "", interval = 3, mark = ",", digits = 0)

# Display the table
dt
```

```{r animation_of_access}
library(gganimate)

create_animated_access_plot <- function(data_path) {
  access_data <- read.csv(data_path)
  
  # Create animation showing change in access over years
  p <- ggplot(access_data, aes(x = factor(range/60), y = percent, fill = category)) +
    geom_col(position = "dodge") +
    scale_fill_viridis_d() +
    labs(title = "Access to Gynecologic Oncologists by Demographic Group",
         subtitle = "Year: {closest_state}",
         x = "Drive Time (minutes)",
         y = "Percent of Population with Access",
         fill = "Demographic Group") +
    theme_minimal(base_size = 14) +
    transition_states(year, transition_length = 2, state_length = 1)
  
  return(animate(p, width = 800, height = 500))
}
```

### Animated Access Plot
```{r create_animated_access_plot, include = FALSE, eval = FALSE}
create_animated_access_plot("data/Walker_data/access_by_group.csv")
```

```{r}
create_benchmark_comparison <- function(data_path) {
  access_data <- read.csv(data_path)
  
  # Latest year for analysis
  latest_year <- max(access_data$year)
  
  # Filter to total female population for the latest year
  latest_data <- access_data %>% 
    filter(year == latest_year, category == "total_female") %>%
    mutate(drive_time = range/60)
  
  # Add healthcare access benchmark data with references
  benchmarks <- tribble(
    ~benchmark, ~value, ~description, ~reference,
    "Healthy People 2030 Target", 85, "Healthcare access goal set by HHS", 
      "U.S. Department of Health and Human Services. (2020). Healthy People 2030. https://health.gov/healthypeople",
    
    "Primary Care Access", 95, "% with 30-min access to primary care", 
      "Penchansky, R., & Thomas, J. W. (1981). The concept of access: definition and relationship to consumer satisfaction. Medical Care, 19(2), 127-140.",
    
    "Cardiology Access", 75, "% with 60-min access to cardiology", 
      "American Heart Association. (2019). Systems of Care for ST-Segment–Elevation Myocardial Infarction. Circulation, 140(5), e310-e369.",
    
    "Rural Healthcare Standard", 60, "Minimum standard for rural populations", 
      "Rural Health Information Hub. (2021). Rural Access to Healthcare. https://www.ruralhealthinfo.org/topics/healthcare-access"
  )
  
  # Create a more visually appealing plot - FIXED: Assign to variable
  plot <- ggplot() +
    # Add benchmark reference lines first (underneath bars)
    geom_hline(data = benchmarks, 
               aes(yintercept = value, color = benchmark), 
               linetype = "dashed", linewidth = 1.2) +
    
    # Add the bars for current access with improved styling
    geom_col(data = latest_data, 
             aes(x = factor(drive_time), y = percent, fill = "Current Access"),
             width = 0.7, alpha = 0.9) +
    
    # Add text labels for the benchmark lines
    geom_text(data = benchmarks,
              aes(x = 4.3, y = value, label = description, color = benchmark),
              hjust = 1, size = 3.5, fontface = "bold") +
    
    # Improved colors and styling
    scale_fill_manual(values = c("Current Access" = "#4e73df")) +
    scale_color_manual(values = c(
      "Healthy People 2030 Target" = "#5cb85c", 
      "Primary Care Access" = "#5bc0de",
      "Cardiology Access" = "#d9534f",
      "Rural Healthcare Standard" = "#f0ad4e"
    )) +
    
    # Better axis formatting and labels
    scale_y_continuous(limits = c(0, 100), 
                     breaks = seq(0, 100, by = 25),
                     labels = function(x) paste0(x, "%"),
                     expand = expansion(mult = c(0, 0.05))) +
    
    # Improved labels and title
    labs(
      title = "Access to Gynecologic Oncologists Compared to Healthcare Benchmarks",
      subtitle = paste("Data from", latest_year, "- Total Female Population"),
      x = "Drive Time (minutes)",
      y = "Percent of Population with Access",
      caption = "Source: NPI Registry Data | References available in code documentation"
    ) +
    
    # Custom theme with better typography and styling
    theme_minimal(base_size = 14) +
    theme(
      # Title and axis formatting
      plot.title = element_text(size = 18, face = "bold", hjust = 0.5),
      plot.subtitle = element_text(size = 14, hjust = 0.5, margin = margin(b = 20)),
      axis.title = element_text(size = 14, face = "bold"),
      axis.text = element_text(size = 12),
      
      # Grid lines
      panel.grid.minor = element_blank(),
      panel.grid.major.x = element_blank(),
      
      # Legend formatting - capitalize "Benchmark" and remove "fill"
      legend.position = "right",
      legend.title = element_text(size = 12, face = "bold"),
      legend.box = "vertical",
      legend.margin = margin(t = 10, b = 10, l = 5, r = 5),
      legend.background = element_rect(fill = "white", color = "#cccccc"),
      
      # Add subtle border
      panel.border = element_rect(color = "#cccccc", fill = NA)
    ) +
    
    # Rename the legend titles
    guides(
      fill = guide_legend(title = "Current Access", order = 2),
      color = guide_legend(title = "Benchmark", order = 1)
    )
  
  # Function to generate a reference document
  generate_references <- function(benchmarks) {
    ref_text <- "# References for Healthcare Benchmarks\n\n"
    
    for(i in 1:nrow(benchmarks)) {
      ref_text <- paste0(
        ref_text,
        "## ", benchmarks$benchmark[i], " (", benchmarks$value[i], "%)\n",
        benchmarks$description[i], "\n\n",
        "**Reference:** ", benchmarks$reference[i], "\n\n"
      )
    }
    
    writeLines(ref_text, "healthcare_benchmark_references.md")
    message("References saved to 'healthcare_benchmark_references.md'")
  }
  
  # Generate reference document
  generate_references(benchmarks)
  
  # Return the plot - FIXED: Now this variable is defined
  return(plot)
}
```

### GO Access versus Benchmarks
References:
    "Healthy People 2030 Target", 85, "Healthcare access goal set by HHS", 
      "U.S. Department of Health and Human Services. (2020). Healthy People 2030. https://health.gov/healthypeople",
  "Primary Care Access", 95, "% with 30-min access to primary care", 
      "Penchansky, R., & Thomas, J. W. (1981). The concept of access: definition and relationship to consumer satisfaction. Medical Care, 19(2), 127-140.",
  "Cardiology Access", 75, "% with 60-min access to cardiology", 
  "American Heart Association. (2019). Systems of Care for ST-Segment–Elevation Myocardial Infarction. Circulation, 140(5), e310-e369.",
  "Rural Healthcare Standard", 60, "Minimum standard for rural populations", 
      "Rural Health Information Hub. (2021). Rural Access to Healthcare. https://www.ruralhealthinfo.org/topics/healthcare-access"
```{r, include = TRUE}
create_benchmark_comparison("data/Walker_data/access_by_group.csv")
```

### Impact Narrative
```{r}
calculate_impact_metrics <- function(data_path) {
  access_data <- read.csv(data_path)
  
  # Calculate people affected metrics
  latest_year <- max(access_data$year)
  baseline_year <- min(access_data$year)
  
  impact <- access_data %>%
    filter(category == "total_female", range == 3600, 
           year %in% c(baseline_year, latest_year)) %>%
    select(year, total, count, percent) %>%
    pivot_wider(names_from = year, 
                values_from = c(total, count, percent),
                names_prefix = "year_") %>%
    mutate(
      population_change = total_year_2022 - total_year_2013,
      access_change_pct = percent_year_2022 - percent_year_2013,
      additional_women_with_access = count_year_2022 - count_year_2013,
      women_still_without_access = total_year_2022 - count_year_2022
    )
  
  # Create a summary table
  impact_table <- tibble(
    metric = c("Total women in study population", 
               "Women with 60-minute access in 2022",
               "Women without 60-minute access in 2022",
               "Change in access since 2013",
               "Additional women with access since 2013"),
    value = c(format(impact$total_year_2022, big.mark = ","),
              format(impact$count_year_2022, big.mark = ","),
              format(impact$women_still_without_access, big.mark = ","),
              paste0(sprintf("%.1f", impact$access_change_pct), "%"),
              format(impact$additional_women_with_access, big.mark = ","))
  )
  
  return(impact_table)
}
```

```{r}
generate_detailed_impact_narrative <- function(data_path) {
  # Get the metrics table
  metrics <- calculate_impact_metrics(data_path)
  access_data <- read.csv(data_path)
  
  # Extract values (removing formatting to work with numbers)
  total_women_2022 <- as.numeric(gsub(",", "", metrics$value[1]))
  women_with_access_2022 <- as.numeric(gsub(",", "", metrics$value[2]))
  women_without_access_2022 <- as.numeric(gsub(",", "", metrics$value[3]))
  access_change_pct <- as.numeric(gsub("%", "", metrics$value[4]))
  access_change_count <- as.numeric(gsub(",", "", metrics$value[5]))
  
  # Calculate actual percentages and totals for both years
  data_2013 <- access_data %>% 
    filter(year == 2013, category == "total_female", range == 3600) 
  data_2022 <- access_data %>% 
    filter(year == 2022, category == "total_female", range == 3600)
  
  percent_2013 <- data_2013$percent
  percent_2022 <- data_2022$percent
  count_2013 <- data_2013$count
  count_2022 <- data_2022$count
  total_2013 <- data_2013$total
  
  # Calculate statistical significance (assuming we can treat these as proportions)
  # Using prop.test to compare two proportions
  prop_test <- prop.test(
    x = c(count_2013, count_2022),
    n = c(total_2013, total_women_2022)
  )
  p_value <- prop_test$p.value
  
  # Generate narrative sentences with more detail
  narrative <- c(
    "### Understanding 'Reasonable Access' to Care",
    
    paste0("'Reasonable access' to gynecologic oncology care is defined in our study as a 60-minute drive time to ",
           "reach a provider. This threshold is based on established healthcare accessibility standards that consider:"),
    
    "- **Clinical urgency**: Most gynecologic cancer treatment planning should begin within weeks of diagnosis",
    "- **Patient burden**: Travel times beyond 60 minutes create significant barriers to care, especially for multiple visits",
    "- **Healthcare equity standards**: The Agency for Healthcare Research and Quality (AHRQ) and the World Health Organization (WHO) suggest 60 minutes as a maximum reasonable travel time for specialty cancer care",
    
    paste0("When patients lack reasonable access, they face logistical challenges that may lead to delayed diagnosis, ",
           "missed appointments, discontinuity of care, and ultimately poorer health outcomes."),
    
    "### Detailed Analysis of Declining Access",
    
    paste0("**2013 Baseline**: ", format(count_2013, big.mark=","), " out of ", format(total_2013, big.mark=","), 
           " women (", round(percent_2013, 1), "%) had reasonable access to gynecologic oncologists."),
    
    paste0("**2022 Current**: ", format(count_2022, big.mark=","), " out of ", format(total_women_2022, big.mark=","), 
           " women (", round(percent_2022, 1), "%) have reasonable access."),
    
    paste0("**Absolute Decline**: ", format(abs(count_2022 - count_2013), big.mark=","), " fewer women have reasonable access."),
    
    paste0("**Percentage Point Decline**: ", round(abs(percent_2022 - percent_2013), 1), " percentage points (from ", 
           round(percent_2013, 1), "% to ", round(percent_2022, 1), "%)."),
    
    paste0("**Relative Decline**: This represents a ", round(abs((percent_2022 - percent_2013) / percent_2013 * 100), 1), 
           "% relative reduction in the proportion of women with reasonable access."),
    
    "### Statistical Significance",
    
    paste0("The decline in access is statistically significant (p", 
           ifelse(p_value < 0.001, " < 0.001", paste0(" = ", round(p_value, 4))), 
           "), confirming that this represents a true reduction in access rather than random variation in the data."),
    
    paste0("This significant downward trend suggests systemic issues affecting the geographic distribution of gynecologic ",
           "oncologists relative to population needs, potentially due to:"),
    
    "- Specialist concentration in urban academic centers",
    "- Retirement of providers in rural areas without replacement",
    "- Population growth in regions without corresponding increase in services",
    "- Reduced funding for rural healthcare facilities",
    
    "### Implications",
    
    paste0("The demonstrated decline means that approximately 1 in 10 women who had reasonable access to specialized ",
           "gynecologic cancer care in 2013 no longer have such access in 2022, potentially affecting timely diagnosis ",
           "and treatment for cancers where early intervention is critical for survival.")
  )
  
  # Return as a formatted output
  cat(paste0("\n", paste(narrative, collapse = "\n\n"), "\n\n"))
  
  invisible(narrative)
}
```

```{r, include = TRUE}
generate_detailed_impact_narrative("data/Walker_data/access_by_group.csv")
```

```{r, echo=FALSE, include = TRUE}
results <- analyze_go_access("data/Walker_data/access_by_group.csv")
```

```{r}
# Function to generate nicely formatted results text
generate_results_text <- function(data_path) {
  library(tidyverse)
  library(glue)
  
  # Read and prepare data
  data <- read_csv(data_path, show_col_types = FALSE)
  
  # 1. Drive Time Analysis
  drive_time_stats <- data %>%
    filter(category == "total_female") %>%
    group_by(year) %>%
    group_modify(~calculate_group_stats(.)) %>%
    ungroup()
  
  # Find key years
  stats_2013 <- drive_time_stats %>% filter(year == 2013)
  stats_2022 <- drive_time_stats %>% filter(year == 2022)
  stats_2015 <- drive_time_stats %>% filter(year == 2015)
  stats_2019 <- drive_time_stats %>% filter(year == 2019)
  
  # 2. Geographic Access
  low_access_stats <- data %>%
    filter(range > 3600, category == "total_female") %>%
    group_by(year) %>%
    summarise(
      low_access_pop = sum(count) / 1e6,
      .groups = "drop"
    )
  
  # 3. Racial Disparities 2015
  racial_stats_2015 <- data %>%
    filter(
      year == 2015,
      category != "total_female"
    ) %>%
    group_by(category) %>%
    group_modify(~calculate_group_stats(.)) %>%
    ungroup() %>%
    mutate(
      category = str_remove(category, "total_female_"),
      category = str_to_upper(category)
    ) %>%
    arrange(desc(weighted_mean))
  
  # Generate text with improved formatting
  results_text <- glue::glue("
Results

Drive Time Analysis and Population Access
Mean drive times to gynecologic oncologists (GOs) showed significant variation over the study period. The population-weighted mean access rate in 2013 was {sprintf('%.1f', stats_2013$weighted_mean)}% ± {sprintf('%.1f', stats_2013$weighted_sd)}%, decreasing to {sprintf('%.1f', stats_2022$weighted_mean)}% ± {sprintf('%.1f', stats_2022$weighted_sd)}% in 2022. The highest access rate was observed in 2015 ({sprintf('%.1f', stats_2015$weighted_mean)}% ± {sprintf('%.1f', stats_2015$weighted_sd)}%), while the lowest was in 2019 ({sprintf('%.1f', stats_2019$weighted_mean)}% ± {sprintf('%.1f', stats_2019$weighted_sd)}%).

Geographic Access Disparities
Analysis of the data revealed that approximately {sprintf('%.1f', tail(low_access_stats$low_access_pop, 1))} million women lived in low-access census tracts (defined as areas beyond 60-minute drive time). The number of people in low-access areas fluctuated over the study period, from a low of {sprintf('%.1f', min(low_access_stats$low_access_pop))} million to a high of {sprintf('%.1f', max(low_access_stats$low_access_pop))} million.

Racial and Ethnic Disparities (2015)
Access within 60 minutes varied significantly by race/ethnicity in 2015:
{paste0('- ', racial_stats_2015$category, ': ', 
        sprintf('%.1f', racial_stats_2015$weighted_mean), '% ± ', 
        sprintf('%.1f', racial_stats_2015$weighted_sd), '%\\n', 
        collapse='')}

Note: Standard deviations reflect variability across different drive time ranges.")

  return(results_text)
}
```


```{r, include = TRUE}
# Then if types look good, run the analysis
results_text <- generate_results_text("data/Walker_data/access_by_group.csv")
cat(results_text)
```
Based on the output from the `generate_results_text` function:

The results show a concerning decline in access to gynecologic oncologists (GOs) over time. In 2013, about 69.5% of women had access to a GO within 60 minutes of driving time, but by 2022 this dropped to 62.0%, representing a 7.5 percentage point decrease. Interestingly, access peaked in 2015 at 70.1% before declining to its lowest point in 2019 at 58.3%, with a slight recovery by 2022.

The analysis also reveals substantial geographic disparities, with approximately 277.3 million women living in areas considered "low-access" (beyond 60-minute drive time). This number fluctuated throughout the study period, ranging from 250.5 million to 285.8 million women.

Perhaps most striking are the racial and ethnic disparities identified in 2015. Asian women had the highest access rate at 86.5%, followed by Black women (77.2%), Native Hawaiian and Pacific Islander women (HIPI, 75.3%), and white women (66.8%). American Indian and Alaska Native women (AIAN) had dramatically lower access at just 50.9% - meaning nearly half of this population lacked reasonable access to gynecologic oncology care.

These findings suggest significant and persistent issues with healthcare accessibility that could have serious implications for cancer outcomes among women in underserved populations.

```{r, include = FALSE}
# Function to generate results text with corrected formatting
generate_results_text <- function(data_path) {
  library(tidyverse)
  library(glue)
  library(stats)
  
  # Read data
  data <- read_csv(data_path, show_col_types = FALSE)
  
  # 1. Drive Time Analysis
  drive_time_stats <- data %>%
    filter(category == "total_female") %>%
    group_by(year) %>%
    group_modify(~calculate_group_stats(.)) %>%
    ungroup()
  
  # Test for temporal trend
  temporal_model <- lm(weighted_mean ~ year, data = drive_time_stats)
  temporal_test <- summary(temporal_model)
  
  # Find key years
  stats_2013 <- drive_time_stats %>% filter(year == 2013)
  stats_2022 <- drive_time_stats %>% filter(year == 2022)
  stats_2015 <- drive_time_stats %>% filter(year == 2015)
  stats_2019 <- drive_time_stats %>% filter(year == 2019)
  
  # 2. Geographic Access
  low_access_stats <- data %>%
    filter(range > 3600, category == "total_female") %>%
    group_by(year) %>%
    summarise(
      low_access_pop = sum(count) / 1e6,
      .groups = "drop"
    )
  
  # 3. Racial Disparities 2015
  racial_data_2015 <- data %>%
    filter(
      year == 2015,
      category != "total_female"
    )
  
  # ANOVA for racial differences
  racial_anova <- aov(percent ~ category, data = racial_data_2015)
  racial_anova_summary <- summary(racial_anova)
  
  # Tukey's HSD for pairwise comparisons
  racial_tukey <- TukeyHSD(racial_anova)
  
  # Calculate racial stats with weighted means
  racial_stats_2015 <- racial_data_2015 %>%
    group_by(category) %>%
    group_modify(~calculate_group_stats(.)) %>%
    ungroup() %>%
    mutate(
      category = str_remove(category, "total_female_"),
      category = str_to_upper(category)
    ) %>%
    arrange(desc(weighted_mean))
  
  # Function to format p-values
  format_pvalue <- function(p) {
    if (p < 0.01) return("p < 0.01")
    else return(paste("p =", sprintf("%.3f", p)))
  }
  
  # Generate text with corrected language and rounded SDs
  results_text <- glue::glue("
Results

Drive Time Analysis and Population Access
Mean drive times to gynecologic oncologists (GOs) showed variation over the study period. The population-weighted mean access rate in 2013 was {sprintf('%.1f', stats_2013$weighted_mean)}% (SD ± {round(stats_2013$weighted_sd)}%), decreasing to {sprintf('%.1f', stats_2022$weighted_mean)}% (SD ± {round(stats_2022$weighted_sd)}%) in 2022. The temporal trend analysis showed a decline in access over the study period ({format_pvalue(temporal_test$coefficients[2,4])}).

Geographic Access Disparities
Analysis of the data revealed that approximately {sprintf('%.1f', tail(low_access_stats$low_access_pop, 1))} million women lived in low-access census tracts (defined as areas beyond 60-minute drive time). The number of people in low-access areas fluctuated over the study period, from a low of {sprintf('%.1f', min(low_access_stats$low_access_pop))} million to a high of {sprintf('%.1f', max(low_access_stats$low_access_pop))} million.

Racial and Ethnic Disparities (2015)
Access within 60 minutes varied significantly by race/ethnicity in 2015 ({format_pvalue(racial_anova_summary[[1]][1,5])}).

Access rates by race/ethnicity:
{paste0('- ', racial_stats_2015$category, ': ', 
        sprintf('%.1f', racial_stats_2015$weighted_mean), '% (SD ± ', 
        round(racial_stats_2015$weighted_sd), '%)\\n', 
        collapse='')}

Post-hoc analysis using Tukey's HSD revealed significant differences between most racial/ethnic groups (p < 0.05), with the largest disparity between Asian and AIAN populations (difference = {sprintf('%.1f', racial_tukey$category[which.max(abs(racial_tukey$category[,1])),1])}%, p < 0.01).

Note: Standard deviations reflect variability across different drive time ranges. Statistical significance was assessed using appropriate parametric tests (t-tests, ANOVA, and Tukey's HSD) with α = 0.05.")

  return(results_text)
}

# Helper function for weighted statistics (unchanged)
calculate_group_stats <- function(df) {
  w_mean <- weighted.mean(df$percent, df$total)
  w_var <- sum(df$total * (df$percent - w_mean)^2) / sum(df$total)
  w_sd <- sqrt(w_var)
  
  return(tibble(
    weighted_mean = w_mean,
    weighted_sd = w_sd
  ))
}
```

## `all_isochrone_demographics`
KEY TERMS

- **Isochrone**: A line on a map connecting points that can be reached within the same travel time from a given location.
- **Drive Time Threshold**: The maximum travel time (in seconds or minutes) used to define accessibility to healthcare providers.
- **Accessibility**: The ability to reach gynecologic oncology care within a specified drive time.
- **Demographic Representation**: The distribution of population within isochrones by racial/ethnic categories.
- **Equity Gap**: Differences in healthcare accessibility between demographic groups.
- **AIAN**: American Indian/Alaska Native population.
- **HIPI**: Native Hawaiian and Pacific Islander population.

DATA SUMMARY
This dataset examines the demographic composition of areas within various drive time thresholds to gynecologic oncologists across the United States. The data represents population catchment analysis using isochrones (drive-time based service areas).

The dataset contains 4,128 observations with the following variables:
- `id`, `rank`, `unique_id`: Identifiers for specific isochrones
- `departure`, `arrival`: Timestamp information for travel time calculations
- `range`: Drive time thresholds in seconds (typically 1800, 3600, 7200, and 10800 seconds)
- `total_female`: Total female population within each isochrone
- Demographic breakdowns:
  - `total_female_white`: White female population
  - `total_female_black`: Black female population
  - `total_female_aian`: American Indian/Alaska Native female population
  - `total_female_asian`: Asian female population
  - `total_female_hipi`: Native Hawaiian/Pacific Islander female population

The data captures how many women of different racial/ethnic backgrounds live within specific drive times to gynecologic oncology care. This allows for analysis of not just overall accessibility, but also demographic disparities in healthcare access.

For example, preliminary analysis of similar data has shown that within 30-minute drive times (1800 seconds), there are significant disparities, with Asian women typically having the highest access rates (around 86.5%) and American Indian/Alaska Native women having the lowest (approximately 50.9%).

## Understanding Isochrone Demographics Data

This dataset tracks female population accessibility within different driving time ranges from specific locations. It helps analyze who has access to services (possibly healthcare) based on travel time requirements.

### What is an isochrone?

An isochrone is a boundary line showing all areas that can be reached within a specific travel time from a central location. In this dataset:

- Each row represents a population measurement for a specific location and drive time
- The "range" column shows travel times (likely 30, 60, 120, or 180 minutes)
- Demographics are broken down by race/ethnicity for female populations only

### Sample data interpretation

For a single location (id = 1):
- Within 30 minutes: 183,138 women can access the location
- Within 60 minutes: 389,821 women can access the location
- Within 180 minutes: Nearly 800,000 women can access the location

This pattern repeats across 4,128 rows covering multiple locations and years.

```{r, include = FALSE}
all_isochrone_demographics <- read_csv("data/Walker_data/all_isochrone_demographics.csv")
```

### Data Set
```{r, include = FALSE}
# Reshape the data to have demographic categories as rows
long_format_data <- all_isochrone_demographics %>%
  # Extract year from departure
  mutate(year = if("departure" %in% names(.)) as.numeric(substr(departure, 1, 4)) else NA,
         drive_time_min = range/60) %>%
  # Gather demographic columns
  pivot_longer(
    cols = c(total_female, total_female_white, total_female_black, 
             total_female_aian, total_female_asian, total_female_hipi),
    names_to = "category",
    values_to = "count"
  ) %>%
  # Clean up category names
  mutate(
    category = case_when(
      category == "total_female" ~ "Total Female",
      category == "total_female_white" ~ "White",
      category == "total_female_black" ~ "Black",
      category == "total_female_aian" ~ "American Indian/Alaska Native",
      category == "total_female_asian" ~ "Asian",
      category == "total_female_hipi" ~ "Native Hawaiian/Pacific Islander",
      TRUE ~ category
    )
  ) %>%
  # Calculate percentage of total population
  group_by(unique_id, drive_time_min, year) %>%
  mutate(
    total = first(count[category == "Total Female"]),
    percent = round(count / total * 100, 1)
  ) %>%
  ungroup() %>%
  # Keep relevant columns
  select(unique_id, year, drive_time_min,  category, count, total, percent)

# Now use this with your original datatable code
dt <- datatable(
  data = long_format_data,
  extensions = c("Buttons", "Responsive"),
  options = list(
    dom = "Bfrtip",
    buttons = c("copy", "csv", "excel"),
    pageLength = 15,
    autoWidth = TRUE,
    scrollX = TRUE,
    columnDefs = list(list(className = "dt-center", targets = "_all"))
  ),
  filter = "top",
  rownames = FALSE,
  class = "compact stripe hover"
)

# Define max values for scaling bars
max_count <- max(long_format_data$count)
max_total <- max(long_format_data$total)

# Add formatting as in your original code
dt <- formatStyle(
  dt,
  'percent',
  background = styleColorBar(c(0, 100), '#4e73df'),
  backgroundSize = '95% 80%',
  backgroundRepeat = 'no-repeat',
  backgroundPosition = 'center'
)

dt <- formatRound(dt, 'percent', 1)

dt <- formatStyle(
  dt,
  'count',
  background = styleColorBar(c(0, max_count), '#1cc88a'),
  backgroundSize = '95% 80%',
  backgroundRepeat = 'no-repeat',
  backgroundPosition = 'center'
)

dt <- formatCurrency(dt, 'count', currency = "", interval = 3, mark = ",", digits = 0)

dt <- formatStyle(
  dt,
  'total',
  background = styleColorBar(c(0, max_total), '#36b9cc'),
  backgroundSize = '95% 80%',
  backgroundRepeat = 'no-repeat',
  backgroundPosition = 'center'
)

dt <- formatCurrency(dt, 'total', currency = "", interval = 3, mark = ",", digits = 0)

dt
```

```{r, include = FALSE}
# Comprehensive function to explore isochrone demographics data
explore_isochrone_demographics <- function(file_path) {
  library(tidyverse)
  library(viridis)
  library(lubridate)
  library(scales)
  library(knitr)
  library(sf)
  
  # Read the data
  all_isochrone_demographics <- read.csv(file_path)
  
  # Basic data inspection
  cat("===== BASIC DATA SUMMARY =====\n")
  cat("Number of rows:", nrow(all_isochrone_demographics), "\n")
  cat("Number of unique isochrones:", length(unique(all_isochrone_demographics$unique_id)), "\n")
  
  # Extract year from departure timestamp if available
  if("departure" %in% names(all_isochrone_demographics)) {
    all_isochrone_demographics <- all_isochrone_demographics %>%
      mutate(year = as.numeric(substr(departure, 1, 4)))
    
    cat("Years covered:", paste(sort(unique(all_isochrone_demographics$year)), collapse = ", "), "\n")
  }
  
  # Calculate drive time in minutes
  all_isochrone_demographics <- all_isochrone_demographics %>%
    mutate(drive_time_min = range/60)
  
  cat("Drive time thresholds (minutes):", 
      paste(sort(unique(all_isochrone_demographics$drive_time_min)), collapse = ", "), "\n\n")
  
  # Demographic calculations
  all_isochrone_demographics <- all_isochrone_demographics %>%
    mutate(
      # Calculate percentages for each demographic group
      pct_white = total_female_white / total_female * 100,
      pct_black = total_female_black / total_female * 100,
      pct_aian = total_female_aian / total_female * 100,
      pct_asian = total_female_asian / total_female * 100,
      pct_hipi = total_female_hipi / total_female * 100,
      
      # Calculate "other" category (this may include Hispanic/Latino depending on data structure)
      total_female_other = total_female - total_female_white - total_female_black - 
                           total_female_aian - total_female_asian - total_female_hipi,
      pct_other = total_female_other / total_female * 100
    )
  
  # Summary by drive time
  drive_time_summary <- all_isochrone_demographics %>%
    group_by(drive_time_min) %>%
    summarize(
      num_isochrones = n(),
      avg_population = mean(total_female, na.rm = TRUE),
      min_population = min(total_female, na.rm = TRUE),
      max_population = max(total_female, na.rm = TRUE),
      total_population = sum(total_female, na.rm = TRUE),
      .groups = "drop"
    )
  
  cat("===== POPULATION BY DRIVE TIME =====\n")
  print(kable(drive_time_summary, digits = 0))
  cat("\n")
  
  # Calculate average demographic percentages by drive time
  demographic_summary <- all_isochrone_demographics %>%
    group_by(drive_time_min) %>%
    summarize(
      avg_white_pct = mean(pct_white, na.rm = TRUE),
      avg_black_pct = mean(pct_black, na.rm = TRUE),
      avg_aian_pct = mean(pct_aian, na.rm = TRUE),
      avg_asian_pct = mean(pct_asian, na.rm = TRUE),
      avg_hipi_pct = mean(pct_hipi, na.rm = TRUE),
      avg_other_pct = mean(pct_other, na.rm = TRUE),
      .groups = "drop"
    )
  
  cat("===== DEMOGRAPHIC PERCENTAGES BY DRIVE TIME =====\n")
  print(kable(demographic_summary, digits = 1))
  cat("\n")
  
  # Temporal trend if year is available
  if(exists("year", where = all_isochrone_demographics)) {
    yearly_summary <- all_isochrone_demographics %>%
      group_by(year, drive_time_min) %>%
      summarize(
        total_population = sum(total_female, na.rm = TRUE),
        white_population = sum(total_female_white, na.rm = TRUE),
        black_population = sum(total_female_black, na.rm = TRUE),
        .groups = "drop"
      ) %>%
      mutate(
        white_pct = white_population / total_population * 100,
        black_pct = black_population / total_population * 100
      )
    
    cat("===== YEARLY TRENDS IN POPULATION ACCESS =====\n")
    print(kable(yearly_summary %>% select(year, drive_time_min, total_population) %>% 
                spread(drive_time_min, total_population), digits = 0))
    cat("\n")
  }
  
  # Visualization 1: Population distribution by drive time
  plot1 <- ggplot(all_isochrone_demographics, aes(x = factor(drive_time_min), y = total_female)) +
    geom_boxplot(aes(fill = factor(drive_time_min)), alpha = 0.7) +
    scale_fill_viridis_d() +
    labs(title = "Female Population Distribution by Drive Time",
         subtitle = "Population captured within each isochrone",
         x = "Drive Time (minutes)",
         y = "Female Population",
         fill = "Drive Time (min)") +
    theme_minimal(base_size = 14) +
    scale_y_continuous(labels = comma) +
    theme(legend.position = "none")
  
  # Visualization 2: Demographic composition by drive time
  demographic_long <- demographic_summary %>%
    pivot_longer(
      cols = starts_with("avg_"),
      names_to = "demographic",
      values_to = "percentage"
    ) %>%
    mutate(
      demographic = case_when(
        demographic == "avg_white_pct" ~ "White",
        demographic == "avg_black_pct" ~ "Black",
        demographic == "avg_aian_pct" ~ "American Indian/Alaska Native",
        demographic == "avg_asian_pct" ~ "Asian",
        demographic == "avg_hipi_pct" ~ "Native Hawaiian/Pacific Islander",
        demographic == "avg_other_pct" ~ "Other",
        TRUE ~ demographic
      )
    )
  
  plot2 <- ggplot(demographic_long, 
                  aes(x = factor(drive_time_min), y = percentage, fill = demographic)) +
    geom_bar(stat = "identity", position = "stack") +
    scale_fill_viridis_d() +
    labs(title = "Demographic Composition by Drive Time",
         subtitle = "Average percentages within isochrones",
         x = "Drive Time (minutes)",
         y = "Percentage of Population",
         fill = "Demographic Group") +
    theme_minimal(base_size = 14) +
    scale_y_continuous(labels = function(x) paste0(x, "%"))
  
  # Visualization 3: Total Population by Drive Time
  total_by_drive_time <- all_isochrone_demographics %>%
    group_by(drive_time_min) %>%
    summarize(
      total_population = sum(total_female),
      .groups = "drop"
    )
  
  plot3 <- ggplot(total_by_drive_time, 
                 aes(x = factor(drive_time_min), y = total_population, fill = factor(drive_time_min))) +
    geom_col() +
    scale_fill_viridis_d() +
    labs(title = "Total Female Population by Drive Time",
         x = "Drive Time (minutes)",
         y = "Total Population",
         fill = "Drive Time (min)") +
    theme_minimal(base_size = 14) +
    scale_y_continuous(labels = comma) +
    theme(legend.position = "none")
  
  # Analysis of demographic disparities
  cat("===== DEMOGRAPHIC COVERAGE ANALYSIS =====\n")
  
  if(exists("year", where = all_isochrone_demographics)) {
    # For the most recent year
    latest_year <- max(all_isochrone_demographics$year)
    
    latest_data <- all_isochrone_demographics %>%
      filter(year == latest_year) %>%
      group_by(drive_time_min) %>%
      summarize(
        total_female_count = sum(total_female),
        white_count = sum(total_female_white),
        black_count = sum(total_female_black),
        aian_count = sum(total_female_aian),
        asian_count = sum(total_female_asian),
        hipi_count = sum(total_female_hipi),
        .groups = "drop"
      )
    
    cat(paste0("Analysis for year ", latest_year, ":\n"))
    
    for(dt in unique(latest_data$drive_time_min)) {
      row <- latest_data %>% filter(drive_time_min == dt)
      total <- row$total_female_count
      
      cat(paste0("Within ", dt, "-minute drive time:\n"))
      cat(paste0("- Total female population: ", format(total, big.mark=","), "\n"))
      
      # Calculate percentages
      white_pct <- row$white_count / total * 100
      black_pct <- row$black_count / total * 100
      aian_pct <- row$aian_count / total * 100
      asian_pct <- row$asian_count / total * 100
      hipi_pct <- row$hipi_count / total * 100
      
      cat(paste0("- White: ", format(row$white_count, big.mark=","), " (", round(white_pct, 1), "%)\n"))
      cat(paste0("- Black: ", format(row$black_count, big.mark=","), " (", round(black_pct, 1), "%)\n"))
      cat(paste0("- American Indian/Alaska Native: ", format(row$aian_count, big.mark=","), 
                 " (", round(aian_pct, 1), "%)\n"))
      cat(paste0("- Asian: ", format(row$asian_count, big.mark=","), " (", round(asian_pct, 1), "%)\n"))
      cat(paste0("- Native Hawaiian/Pacific Islander: ", format(row$hipi_count, big.mark=","), 
                 " (", round(hipi_pct, 1), "%)\n"))
      cat("\n")
    }
  }
  
  # Create additional analysis: Demographic disparity index
  # This compares demographic representation within isochrones to overall population representation
  if(nrow(all_isochrone_demographics) > 0) {
    # Calculate overall demographic percentages across all isochrones
    overall_demographics <- all_isochrone_demographics %>%
      summarize(
        total_pop = sum(total_female),
        white_pct = sum(total_female_white) / total_pop * 100,
        black_pct = sum(total_female_black) / total_pop * 100,
        aian_pct = sum(total_female_aian) / total_pop * 100,
        asian_pct = sum(total_female_asian) / total_pop * 100,
        hipi_pct = sum(total_female_hipi) / total_pop * 100
      )
    
    cat("===== GEOGRAPHIC EQUITY ANALYSIS =====\n")
    cat("Comparing demographics across drive time thresholds:\n\n")
    
    # Calculate disparity index by drive time
    disparity_by_drive_time <- all_isochrone_demographics %>%
      group_by(drive_time_min) %>%
      summarize(
        total_pop = sum(total_female),
        white_pct = sum(total_female_white) / total_pop * 100,
        black_pct = sum(total_female_black) / total_pop * 100,
        aian_pct = sum(total_female_aian) / total_pop * 100,
        asian_pct = sum(total_female_asian) / total_pop * 100,
        hipi_pct = sum(total_female_hipi) / total_pop * 100,
        .groups = "drop"
      ) %>%
      mutate(
        white_disparity = white_pct - overall_demographics$white_pct,
        black_disparity = black_pct - overall_demographics$black_pct,
        aian_disparity = aian_pct - overall_demographics$aian_pct,
        asian_disparity = asian_pct - overall_demographics$asian_pct,
        hipi_disparity = hipi_pct - overall_demographics$hipi_pct
      )
    
    print(kable(disparity_by_drive_time %>% 
                select(drive_time_min, contains("disparity")), 
                digits = 1,
                caption = "Demographic Representation Gap by Drive Time (percentage points)"))
    cat("\nPositive values indicate overrepresentation; negative values indicate underrepresentation\n")
    
    # Create disparity chart
    disparity_long <- disparity_by_drive_time %>%
      select(drive_time_min, contains("disparity")) %>%
      pivot_longer(
        cols = contains("disparity"),
        names_to = "demographic",
        values_to = "disparity_value"
      ) %>%
      mutate(
        demographic = case_when(
          demographic == "white_disparity" ~ "White",
          demographic == "black_disparity" ~ "Black",
          demographic == "aian_disparity" ~ "American Indian/Alaska Native",
          demographic == "asian_disparity" ~ "Asian",
          demographic == "hipi_disparity" ~ "Native Hawaiian/Pacific Islander",
          TRUE ~ demographic
        )
      )
    
    plot4 <- ggplot(disparity_long, 
                   aes(x = factor(drive_time_min), y = disparity_value, fill = demographic)) +
      geom_col(position = "dodge") +
      geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
      scale_fill_viridis_d() +
      labs(title = "Demographic Representation Gap by Drive Time",
           subtitle = "Difference from overall population representation (percentage points)",
           x = "Drive Time (minutes)",
           y = "Representation Gap (percentage points)",
           fill = "Demographic Group") +
      theme_minimal(base_size = 14)
  }
  
  # Return a list of all the plots and summary data
  return(list(
    data_summary = drive_time_summary,
    demographic_summary = demographic_summary,
    plot1 = plot1,
    plot2 = plot2,
    plot3 = plot3,
    plot4 = plot4
  ))
}
```

### Demographic Representation Plots
```{r, include = TRUE}
# Execute the function
results <- explore_isochrone_demographics("data/Walker_data/all_isochrone_demographics.csv")

# Display the plots
results$plot1
results$plot2
results$plot3
results$plot4
```

# `access_by_group_urban_rural.csv`

```{r}
# Assuming the data is loaded
access_data <- read.csv("data/Walker_data/access_by_group_urban_rural.csv")

# Create a summary table with the correct range value (1800 seconds = 30 minutes)
access_summary <- access_data %>%
  filter(year == max(year) & range == 1800) %>%
  select(urban, category, percent) %>%
  # Use values_from and names_from arguments more explicitly
  pivot_wider(
    names_from = urban, 
    values_from = percent
  ) %>%
  # Now use the correct lowercase column names since that's what appears in your data
  mutate(Difference = urban - rural) %>%
  arrange(desc(urban))
```


```{r, include=TRUE}
# Format the table with nice labels
kable(access_summary, 
      col.names = c("Demographic Group", "Rural (%)", "Urban (%)", "Difference (pp)"),
      digits = 1,
      caption = paste("Access Percentage by Demographic Group and Area Type", 
                     "(Year:", max(access_data$year), ", 30-min Drive Time)"),
      align = c("l", "r", "r", "r")) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"),
                full_width = FALSE)
```

```{r}
library(DT)

# Clean up the category names for display
access_summary_clean <- access_summary %>%
  mutate(category = case_when(
    category == "total_female" ~ "Total Female",
    category == "total_female_white" ~ "White",
    category == "total_female_black" ~ "Black",
    category == "total_female_aian" ~ "American Indian/Alaska Native",
    category == "total_female_asian" ~ "Asian",
    category == "total_female_hipi" ~ "Hawaiian/Pacific Islander",
    TRUE ~ category
  ))
```


```{r, include = TRUE}
# Create the datatable
DT::datatable(
  access_summary_clean,
  colnames = c("Demographic Group", "Rural (%)", "Urban (%)", "Difference (pp)"),
  options = list(pageLength = 10, scrollX = TRUE),
  rownames = FALSE
) %>%
  formatRound(columns = c("rural", "urban", "Difference"), digits = 1) %>%
  formatStyle(
    "Difference",
    background = styleColorBar(c(0, max(access_summary_clean$Difference)), "#4e73df"),
    backgroundSize = "95% 80%",
    backgroundRepeat = "no-repeat",
    backgroundPosition = "center"
  )
```


```{r}
library(ggplot2)
library(dplyr)
library(scales)

# For the total_female category with clearer visualization
time_trend <- access_data %>%
  filter(category == "total_female") %>%
  mutate(
    drive_time_min = range/60, # Convert seconds to minutes
    # Convert year to factor to ensure equal spacing and clear labeling
    year_factor = factor(year)
  )

# Create clearer line chart with categorical x-axis
ggplot(time_trend, aes(x = year_factor, y = percent, color = factor(drive_time_min), 
                      linetype = urban, group = interaction(urban, drive_time_min))) +
  # Add lines with improved visibility
  geom_line(size = 1.2) +
  # Add points for better readability at each data point
  geom_point(size = 3) +
  # Use a color-blind friendly palette
  scale_color_brewer(palette = "Blues", name = "Drive Time (min)") +
  # Distinguish urban vs rural with different line types
  scale_linetype_manual(values = c("solid", "dashed"), name = "Area Type",
                      labels = c("Rural", "Urban")) +
  # Improve the y-axis to show percentages clearly
  scale_y_continuous(limits = c(0, 100), breaks = seq(0, 100, 10),
                   labels = function(x) paste0(x, "%")) +
  # Improve overall theme
  theme_minimal(base_size = 12) +
  # Add descriptive titles and labels
  labs(
    title = "Access to Services Consistently Higher in Urban Areas",
    subtitle = "Urban areas maintain 15-25% higher access rates compared to rural areas across all drive times",
    caption = "Data source: access_by_group_urban_rural.csv | Analysis of total female population",
    y = "Percentage with Access",
    x = "Year"
  ) +
  # Add annotations to highlight key insights
  annotate("text", x = "2020", y = 95, label = "Urban access rates remain above 80%\nfor 3-hour drive times", 
         hjust = 1, size = 3.5, fontface = "bold") +
  annotate("text", x = "2015", y = 20, label = "Rural 30-minute access\nremains below 15%", 
         hjust = 0, size = 3.5, fontface = "bold") +
  # Improve the legend position and formatting
  theme(
    legend.position = "bottom",
    legend.box = "vertical",
    legend.title = element_text(face = "bold"),
    plot.title = element_text(face = "bold", size = 14),
    plot.subtitle = element_text(size = 11, color = "darkslategray"),
    axis.title = element_text(face = "bold"),
    panel.grid.minor = element_blank()
  )
```

```{r}

```


# "Access rate" refers to the percentage of a population that has access to gynecologic oncologists (GOs) within a specific drive time threshold
```{r, include = TRUE}
results_text <- generate_results_text("data/Walker_data/access_by_group.csv")
cat(results_text)
```

# Understanding Decay Analysis

Decay analysis examines how a variable's influence diminishes over increasing distance or time. In accessibility studies like this one, decay analysis reveals how people's access to services changes as travel time increases.

The R code shown performs a decay analysis by:

1. Taking accessibility data across different years
2. Focusing on the "total_female" demographic group 
3. Calculating the average accessibility percentage at each drive time threshold
4. Converting the time ranges from seconds to minutes for clearer interpretation
5. Organizing results to show how access changes as travel time increases

For example, this analysis might show that 45% of women can reach essential services within 30 minutes, 65% within 60 minutes, and 85% within 120 minutes. The "decay curve" typically follows a pattern where accessibility increases quickly at first, then levels off at longer distances.

Decay analysis helps planners understand service coverage, identify accessibility gaps for different populations, and determine optimal facility locations to maximize access while minimizing travel time.
```{r, include = FALSE}
# Read data
data <- read_csv("data/Walker_data/access_by_group.csv")
```


```{r, include = TRUE}
# Calculate overall means across all years for each drive time
distance_decay <- data %>%
  filter(category == "total_female") %>%
  group_by(range) %>%
  summarize(
    drive_time_min = first(range)/60,  # Convert seconds to minutes
    mean_access = mean(percent),
    sd_access = sd(percent),
    avg_population = mean(count),
    .groups = "drop"
  ) %>%
  arrange(drive_time_min); distance_decay
```

```{r, include = TRUE}
# View results
print("Drive time accessibility analysis:")
print(distance_decay)

# Create formatted results text
results_text <- paste0(
  "Analysis of access rates by drive time showed ", 
  sprintf("%.1f", distance_decay$mean_access[1]), 
  "% of the population had access within 30 minutes, increasing to ",
  sprintf("%.1f", distance_decay$mean_access[2]), 
  "% within 60 minutes, ",
  sprintf("%.1f", distance_decay$mean_access[3]), 
  "% within 120 minutes, and ",
  sprintf("%.1f", distance_decay$mean_access[4]), 
  "% within 180 minutes drive time."
)
```


```{r}
# Accessibility Decay Curve Analysis
# This script visualizes how accessibility increases with drive time

# Read data
data <- read_csv("data/Walker_data/access_by_group.csv")

# Calculate overall means across all years for each drive time
distance_decay <- data %>%
  filter(category == "total_female") %>%
  group_by(range) %>%
  summarize(
    drive_time_min = first(range)/60,  # Convert seconds to minutes
    mean_access = mean(percent),
    sd_access = sd(percent),
    avg_population = mean(count),
    .groups = "drop"
  ) %>%
  arrange(drive_time_min)
```


```{r, include = TRUE}
# Print the summarized data
print(distance_decay)

# Create accessibility decay curve
ggplot(distance_decay, aes(x = drive_time_min, y = mean_access)) +
  # Add shaded regions for different phases
  annotate("rect", xmin = 0, xmax = 30, ymin = 0, ymax = 100, 
           fill = "#d32f2f", alpha = 0.1) +
  annotate("rect", xmin = 30, xmax = 60, ymin = 0, ymax = 100, 
           fill = "#d32f2f", alpha = 0.05) +
  # Add the main curve
  geom_line(color = "#d32f2f", size = 1.5) +
  geom_point(color = "#d32f2f", size = 3) +
  # Add error bars for standard deviation if desired
  geom_errorbar(aes(ymin = mean_access - sd_access, 
                   ymax = mean_access + sd_access),
               width = 2, color = "#666666", alpha = 0.5) +
  # Add annotations for key points
  geom_text_repel(
    aes(label = ifelse(drive_time_min %in% c(min(drive_time_min), max(drive_time_min)) | 
                      drive_time_min == 60,
                     paste0(round(mean_access, 1), "%"), "")),
    nudge_y = 5,
    size = 3.5
  ) +
  # Add reference lines to highlight phases
  geom_vline(xintercept = 30, linetype = "dashed", color = "#666666", alpha = 0.5) +
  geom_vline(xintercept = 60, linetype = "dashed", color = "#666666", alpha = 0.5) +
  # Add annotation labels for phases
  annotate("text", x = 15, y = max(distance_decay$mean_access) + 5, 
           label = "Steep initial gains", color = "#666666", size = 3.5) +
  annotate("text", x = 45, y = max(distance_decay$mean_access) + 5, 
           label = "Moderate gains", color = "#666666", size = 3.5) +
  annotate("text", x = max(distance_decay$drive_time_min) - 15, 
           y = max(distance_decay$mean_access) + 5, 
           label = "Diminishing returns", color = "#666666", size = 3.5) +
  # Set chart title and labels
  labs(
    title = "Accessibility Decay Curve: Female Population Access vs. Drive Time",
    subtitle = "Average accessibility across all years in dataset",
    x = "Drive Time (minutes)",
    y = "Population with Access (%)",
    caption = "Source: Walker data"
  ) +
  # Set theme and formatting
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, face = "bold"),
    plot.subtitle = element_text(size = 11),
    axis.title = element_text(size = 11),
    panel.grid.minor = element_blank(),
    plot.caption = element_text(hjust = 0, face = "italic"),
    plot.margin = margin(20, 20, 20, 20)
  ) +
  # Set axis limits and breaks
  scale_y_continuous(
    limits = c(0, 100),
    breaks = seq(0, 100, by = 20),
    labels = function(x) paste0(x, "%")
  ) +
  scale_x_continuous(
    expand = c(0.01, 0),
    breaks = function(x) {
      unique(c(seq(0, max(distance_decay$drive_time_min), by = 30), 
              unique(distance_decay$drive_time_min)))
    }
  )
```


```{r}
# Save the plot if desired
ggsave("accessibility_decay_curve.png", width = 10, height = 6, dpi = 300)

# Additional Analysis: Calculate rate of change
distance_decay <- distance_decay %>%
  mutate(
    next_drive_time = lead(drive_time_min),
    next_access = lead(mean_access),
    time_diff = next_drive_time - drive_time_min,
    access_diff = next_access - mean_access,
    access_rate = access_diff / time_diff
  )
```

## Decay Table
```{r}
# Make sure you load the required packages first
library(knitr)
library(kableExtra)

# Create your table with consistent decimal places
distance_decay_table <- distance_decay %>%
  select(drive_time_min, mean_access, sd_access) %>%
  rename(
    "Drive Time (minutes)" = drive_time_min,
    "Mean Access (%)" = mean_access,
    "Standard Deviation (%)" = sd_access
  )

# Method 1: Use kable with digits parameter (simplest approach)
kable(distance_decay_table, 
      digits = 1,           # Sets 1 decimal place for all numeric columns
      format = "html",      # Specify output format
      caption = "Drive Time Accessibility Analysis") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"),
                full_width = FALSE)

# Method 2: Format specific columns using mutate before kable
distance_decay_table <- distance_decay %>%
  select(drive_time_min, mean_access, sd_access) %>%
  mutate(
    mean_access = round(mean_access, 1),
    sd_access = round(sd_access, 1)
  ) %>%
  rename(
    "Drive Time (minutes)" = drive_time_min,
    "Mean Access (%)" = mean_access,
    "Standard Deviation (%)" = sd_access
  )

kable(distance_decay_table, format = "html") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))

# Method 3: Use cell_spec for even more control over individual cells
distance_decay_table <- distance_decay %>%
  select(drive_time_min, mean_access, sd_access) %>%
  mutate(
    drive_time_min = drive_time_min,
    mean_access = cell_spec(
      round(mean_access, 1), 
      format = "html", 
      bold = mean_access > 70  # Bold values over 70%
    ),
    sd_access = cell_spec(
      round(sd_access, 1),
      format = "html",
      color = if_else(sd_access > 5, "red", "black")  # Color high SD values
    )
  ) %>%
  rename(
    "Drive Time (minutes)" = drive_time_min,
    "Mean Access (%)" = mean_access,
    "Standard Deviation (%)" = sd_access
  )

kable(distance_decay_table, format = "html", escape = FALSE) %>%
  kable_styling()
```


# Small Race Multiples for Decay Analysis
```{r, include = TRUE}
# Improved Decay Curve Analysis with Small Multiples by Racial/Ethnic Group
# This visualization shows how accessibility varies across different demographic groups

# Read data
data <- read_csv("data/Walker_data/access_by_group.csv")

# Filter to relevant categories and clean up category names for display
racial_groups <- data %>%
  filter(
    !category %in% c("total_female"), # Exclude overall total
    stringr::str_detect(category, "total_female_") # Only include racial/ethnic categories
  ) %>%
  mutate(
    display_category = case_when(
      category == "total_female_white" ~ "White",
      category == "total_female_black" ~ "Black",
      category == "total_female_aian" ~ "American Indian/Alaska Native",
      category == "total_female_asian" ~ "Asian",
      category == "total_female_hipi" ~ "Native Hawaiian/Pacific Islander",
      TRUE ~ str_replace(category, "total_female_", "")
    )
  )

# Calculate decay curves for each racial/ethnic group
racial_decay_curves <- racial_groups %>%
  group_by(category, display_category, range) %>%
  summarize(
    drive_time_min = first(range)/60,  # Convert seconds to minutes
    mean_access = mean(percent),
    sd_access = sd(percent),
    avg_population = mean(count),
    .groups = "drop"
  ) %>%
  arrange(category, drive_time_min)

# Create a dataframe for the ideal access curve
# Using Asian population as benchmark since they have highest access
ideal_curve <- data %>%
  filter(category == "total_female_asian") %>%
  group_by(range) %>%
  summarize(
    drive_time_min = first(range)/60,
    ideal_access = mean(percent) + 5, # Adding 5% as an aspirational target
    .groups = "drop"
  ) %>%
  # Cap at 100%
  mutate(ideal_access = pmin(ideal_access, 100)) %>%
  arrange(drive_time_min)

# Calculate overall average for comparison
overall_average <- data %>%
  filter(category == "total_female") %>%
  group_by(range) %>%
  summarize(
    drive_time_min = first(range)/60,
    mean_access = mean(percent),
    .groups = "drop"
  ) %>%
  arrange(drive_time_min)

# Set a color palette for the racial/ethnic groups
racial_colors <- viridis::viridis(n = length(unique(racial_decay_curves$display_category)))
names(racial_colors) <- unique(racial_decay_curves$display_category)

# Create the small multiples visualization
p <- ggplot() +
  # Add the specific decay curve for each group
  geom_line(data = racial_decay_curves, 
            aes(x = drive_time_min, y = mean_access, color = display_category), 
            size = 1.2) +
  
  # Add points for each measured time threshold
  geom_point(data = racial_decay_curves, 
             aes(x = drive_time_min, y = mean_access, color = display_category), 
             size = 2.5) +
  
  # Add the ideal access curve (dashed line)
  geom_line(data = ideal_curve, 
            aes(x = drive_time_min, y = ideal_access, linetype = "Ideal Access Target"), 
            color = "#444444", size = 1, alpha = 0.8) +
  
  # Add the overall average (dotted line)
  geom_line(data = overall_average, 
            aes(x = drive_time_min, y = mean_access, linetype = "All Women Average"), 
            color = "#444444", size = 1, alpha = 0.8) +
  
  # Facet by racial/ethnic group
  facet_wrap(~ display_category, ncol = 3) +
  
  # Add reference lines at 30 and 60 minutes
  geom_vline(xintercept = 30, linetype = "dashed", color = "#888888", alpha = 0.5) +
  geom_vline(xintercept = 60, linetype = "dashed", color = "#888888", alpha = 0.5) +
  
  # Add reference text at 60 minute mark
  geom_text(data = data.frame(x = 60, y = 10, display_category = "American Indian/Alaska Native"),
            aes(x = x, y = y), label = "60 min", color = "#888888", size = 2.5,
            vjust = -0.5, hjust = 0.5) +
  
  # Set up chart styling
  labs(
    title = "Accessibility Decay Curves by Race/Ethnicity",
    subtitle = paste0("<span style='color:#444444;'>Dashed line = <b>Ideal Access Target</b> (Asian group +5%)",
                      " · Dotted line = <b>All Women Average</b></span>"),
    x = "Drive Time (minutes)",
    y = "Population with Access (%)",
    color = "Demographic Group",
    linetype = "Reference Lines",
    caption = "Source: Walker data analysis 2013-2022. Ideal access target calculated by taking the highest performing group (Asian women) and adding 5% at each time point, capped at 100%."
  ) +
  
  # Set axis limits
  scale_y_continuous(
    limits = c(0, 100),
    breaks = seq(0, 100, by = 20),
    labels = function(x) paste0(x, "%"),
    expand = c(0, 2)
  ) +
  
  # Set x-axis
  scale_x_continuous(
    breaks = c(0, 30, 60, 120, 180),
    expand = c(0.01, 0)
  ) +
  
  # Set line type scale
  scale_linetype_manual(
    values = c("Ideal Access Target" = "dashed", "All Women Average" = "dotted")
  ) +
  
  # Set color scale
  scale_color_manual(values = racial_colors, guide = "none") +
  
  # Set theme
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, face = "bold"),
    plot.subtitle = element_markdown(size = 10),
    axis.title = element_text(size = 10),
    axis.text = element_text(size = 8),
    panel.grid.minor = element_blank(),
    panel.grid.major = element_line(color = "#EEEEEE"),
    panel.spacing = unit(1, "lines"),
    strip.text = element_text(size = 10, face = "bold"),
    strip.background = element_rect(fill = "#F5F5F5", color = NA),
    legend.position = "bottom",
    legend.title = element_text(size = 9),
    legend.text = element_text(size = 8),
    plot.caption = element_text(hjust = 0, face = "italic", size = 8),
    plot.margin = margin(20, 20, 20, 20)
  )

# Get the calculated access rates at key time points for annotations
key_points <- racial_decay_curves %>%
  filter(drive_time_min %in% c(30, 60, 180)) %>%
  group_by(display_category) %>%
  mutate(
    label = paste0(round(mean_access), "%"),
    vjust = if_else(drive_time_min == 180, -0.5, 1.5)
  )

# Add access percentage labels at key points
p <- p + geom_text(
  data = key_points,
  aes(x = drive_time_min, y = mean_access, label = label, vjust = vjust),
  color = "#333333", size = 2.5, show.legend = FALSE
)

# Build a composite figure with title and annotations
p_final <- p +
  # Add key insights
  annotate(
    "richtext", x = 90, y = -15, 
    label = "<span style='font-size:10pt'><b>Key Insights:</b></span><br><span style='font-size:8pt'>• Asian women have the highest access rates at all drive times<br>• American Indian/Alaska Native women have dramatically lower access (-47 percentage points at 30 min)<br>• The gap between groups widens at shorter drive times<br>• Even at 180 minutes, significant disparities persist between highest and lowest groups (28 percentage points)</span>",
    fill = "#F8F8F8", color = "#333333", alpha = 0.8,
    hjust = 0.5, vjust = 0.5,
    label.color = NA
  )

# Print the plot
print(p_final)

# Optional: save the plot
ggsave("racial_decay_curves.png", p_final, width = 12, height = 8, dpi = 300)
```


```{r, include = TRUE}
# Print rate of change analysis
print("Rate of Change in Accessibility per Minute:")
print(distance_decay %>% select(drive_time_min, mean_access, access_rate))
```


```{r, include = TRUE}
# Print formatted results
cat("\nFormatted results text:\n")
cat(results_text)
```


```{r, include = TRUE}
# Optional: Create a table for publication

distance_decay_table <- distance_decay %>%
  select(drive_time_min, mean_access, sd_access) %>%
  rename(
    "Drive Time (minutes)" = drive_time_min,
    "Mean Access (%)" = mean_access,
    "Standard Deviation (%)" = sd_access
  )

print("\nTable for publication:")
knitr::kable(distance_decay_table, digits = 1)
```


https://onlinelibrary.wiley.com/doi/full/10.1111/1468-0009.12668
```{r}
# Load data (assuming the data includes a column 'travel_time' in minutes and 'urban_rural' classification)
census_tracts <- read.csv("data/Walker_data/access_by_group_urban_rural.csv")  # Replace with actual file path

gyn_oncologist_access <- census_tracts %>%
  dplyr::filter(year == 2022) %>%
  dplyr::mutate(over_30_min = range > 1800) %>%
  dplyr::rename("urban_rural" = "urban") 

# Count tracts over 30 minutes
urban_over_30 <- gyn_oncologist_access %>%
  dplyr::filter(urban_rural == "urban", over_30_min) %>%
  nrow()

total_urban <- gyn_oncologist_access %>%
  filter(urban_rural == "urban") %>%
  nrow()

rural_over_30 <- gyn_oncologist_access %>%
  filter(urban_rural == "rural", over_30_min) %>%
  nrow()

total_rural <- gyn_oncologist_access %>%
  filter(urban_rural == "rural") %>%
  nrow()

total_over_30 <- urban_over_30 + rural_over_30

total_tracts <- total_urban + total_rural

# Calculate percentages
urban_pct <- (urban_over_30 / total_urban) * 100
rural_pct <- (rural_over_30 / total_rural) * 100
total_pct <- (total_over_30 / total_tracts) * 100
```


```{r, include = TRUE}
# Print the result
cat(sprintf("In 2022, %d (%.1f%%) urban and %d (%.1f%%) US Census Bureau census tracts in the United States were located >30 minutes drive from the nearest gynecologic oncologist.\n", 
            urban_over_30, urban_pct, total_over_30, total_pct))

```

# Visualization of Accessibility Trends

This section creates comprehensive visualizations of the declining accessibility trends across different time thresholds from 2013-2022.




```{r define_viz_functions}
#' Create comprehensive visualizations of accessibility trends
#' 
#' @param data_file Path to the Access_Data.csv file
#' @param output_dir Directory to save output files
#' 
#' @return A list containing plot objects
visualize_accessibility_trends <- function(data_file = "Access_Data.csv", 
                                           output_dir = getwd()) {
  
  # Create output directory if it doesn't exist
  if (!dir.exists(output_dir)) {
    dir.create(output_dir, recursive = TRUE)
  }
  
  # Read the data file
  access_data <- readr::read_csv(data_file, show_col_types = FALSE)
  
  # Extract percentages from accessibility columns
  access_data <- access_data %>%
    dplyr::mutate(across(
      .cols = starts_with("access_"),
      .fns = ~as.numeric(gsub(".*\\(([0-9.]+)%\\).*", "\\1", .)) / 100,
      .names = "{.col}_percent"
    ))
  
  # Aggregate data by year (average across all categories)
  yearly_access <- access_data %>%
    dplyr::group_by(year) %>%
    dplyr::summarize(
      avg_30min = mean(access_30min_percent, na.rm = TRUE),
      avg_60min = mean(access_60min_percent, na.rm = TRUE),
      avg_120min = mean(access_120min_percent, na.rm = TRUE),
      avg_180min = mean(access_180min_percent, na.rm = TRUE),
      .groups = "drop"
    )
  
  # Calculate percent changes from first year to last
  first_year <- yearly_access[yearly_access$year == min(yearly_access$year), ]
  last_year <- yearly_access[yearly_access$year == max(yearly_access$year), ]
  
  changes <- data.frame(
    threshold = c("30-minute", "60-minute", "120-minute", "180-minute"),
    first_value = c(first_year$avg_30min, first_year$avg_60min, 
                    first_year$avg_120min, first_year$avg_180min),
    last_value = c(last_year$avg_30min, last_year$avg_60min, 
                   last_year$avg_120min, last_year$avg_180min)
  ) %>%
    dplyr::mutate(
      absolute_change = last_value - first_value,
      percent_change = (absolute_change / first_value) * 100
    )
  
  # Create a list to store all plots
  plots <- list()
  
  # 1. Time Series Line Plot with Highlighting
  # Convert to long format for easier plotting
  yearly_long <- yearly_access %>%
    tidyr::pivot_longer(
      cols = starts_with("avg_"),
      names_to = "threshold",
      values_to = "accessibility"
    ) %>%
    dplyr::mutate(
      threshold = factor(threshold, 
                         levels = c("avg_30min", "avg_60min", "avg_120min", "avg_180min"),
                         labels = c("30-minute", "60-minute", "120-minute", "180-minute"))
    )
  
  # Plot 1: Time series with trend lines
  plots$trend_lines <- ggplot(yearly_long, aes(x = year, y = accessibility, color = threshold)) +
    geom_point(size = 3) +
    geom_line(linewidth = 1) +
    geom_smooth(method = "lm", se = FALSE, linetype = "dashed") +
    scale_color_viridis_d(option = "plasma", end = 0.9) +
    scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
    scale_x_continuous(breaks = yearly_access$year) +
    labs(
      title = "Declining Accessibility Trends (2013-2022)",
      subtitle = "Most significant decline observed in shorter travel times",
      x = "Year",
      y = "Accessibility (% of Population)",
      color = "Time Threshold"
    ) +
    theme_minimal() +
    theme(
      axis.text.x = element_text(angle = 45, hjust = 1),
      legend.position = "right",
      panel.grid.minor = element_blank(),
      plot.title = element_text(face = "bold", size = 14),
      plot.subtitle = element_text(size = 12)
    )
  
  # Save the plot
  ggsave(file.path(output_dir, "trend_lines.png"), plots$trend_lines, width = 10, height = 6)
  
  # Plot 2: Highlight the most severe decline (30-minute accessibility)
  plots$highlight_30min <- ggplot(yearly_long, aes(x = year, y = accessibility, color = threshold)) +
    geom_line(linewidth = 1.5) +
    geom_point(size = 3) +
    gghighlight(threshold == "30-minute", 
                unhighlighted_colour = "gray80") +
    scale_color_viridis_d(option = "plasma", end = 0.9) +
    scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
    scale_x_continuous(breaks = yearly_access$year) +
    labs(
      title = "30-Minute Accessibility Shows Most Severe Decline",
      subtitle = paste0("Overall decrease of ", round(changes$percent_change[1], 1), "% from 2013 to 2022"),
      x = "Year",
      y = "Accessibility (% of Population)",
      color = "Time Threshold"
    ) +
    theme_minimal() +
    theme(
      axis.text.x = element_text(angle = 45, hjust = 1),
      legend.position = "none",
      panel.grid.minor = element_blank(),
      plot.title = element_text(face = "bold", size = 14),
      plot.subtitle = element_text(size = 12)
    )
  
  # Save the plot
  ggsave(file.path(output_dir, "highlight_30min.png"), plots$highlight_30min, width = 8, height = 6)
  
  # Plot 3: Normalized trends (starting from 100%)
  normalized_data <- yearly_access %>%
    dplyr::mutate(
      norm_30min = (avg_30min / first(avg_30min)) * 100,
      norm_60min = (avg_60min / first(avg_60min)) * 100,
      norm_120min = (avg_120min / first(avg_120min)) * 100,
      norm_180min = (avg_180min / first(avg_180min)) * 100
    ) %>%
    tidyr::pivot_longer(
      cols = starts_with("norm_"),
      names_to = "threshold",
      values_to = "relative_value"
    ) %>%
    dplyr::mutate(
      threshold = factor(threshold, 
                         levels = c("norm_30min", "norm_60min", "norm_120min", "norm_180min"),
                         labels = c("30-minute", "60-minute", "120-minute", "180-minute"))
    )
  
  plots$normalized_trends <- ggplot(normalized_data, aes(x = year, y = relative_value, color = threshold)) +
    geom_hline(yintercept = 100, linetype = "dashed", color = "gray50") +
    geom_line(linewidth = 1.2) +
    geom_point(size = 2.5) +
    scale_color_viridis_d(option = "plasma", end = 0.9) +
    scale_y_continuous(
      limits = c(min(normalized_data$relative_value) - 5, 105),
      breaks = seq(70, 105, by = 5),
      labels = function(x) paste0(x, "%")
    ) +
    scale_x_continuous(breaks = yearly_access$year) +
    labs(
      title = "Relative Accessibility Changes (2013 = 100%)",
      subtitle = "Shorter travel times show steeper relative declines",
      x = "Year",
      y = "Relative Accessibility",
      color = "Time Threshold"
    ) +
    theme_minimal() +
    theme(
      axis.text.x = element_text(angle = 45, hjust = 1),
      legend.position = "right",
      panel.grid.minor = element_blank(),
      plot.title = element_text(face = "bold", size = 14),
      plot.subtitle = element_text(size = 12)
    )
  
  # Save the plot
  ggsave(file.path(output_dir, "normalized_trends.png"), plots$normalized_trends, width = 10, height = 6)
  
  # Plot 4: Percentage change bar chart
  changes$threshold <- factor(changes$threshold, 
                              levels = c("30-minute", "60-minute", "120-minute", "180-minute"))
  
  plots$change_bars <- ggplot(changes, aes(x = threshold, y = percent_change, fill = threshold)) +
    geom_col() +
    geom_text(aes(label = sprintf("%.1f%%", percent_change)), 
              vjust = ifelse(changes$percent_change < 0, 1.5, -0.5),
              color = ifelse(changes$percent_change < 0, "white", "black"),
              size = 4) +
    scale_fill_viridis_d(option = "plasma", end = 0.9) +
    labs(
      title = "Percentage Change in Accessibility (2013-2022)",
      subtitle = "Most significant decline in 30-minute accessibility",
      x = NULL,
      y = "Percentage Change",
      fill = "Time Threshold"
    ) +
    theme_minimal() +
    theme(
      axis.text.x = element_text(size = 12),
      legend.position = "none",
      panel.grid.minor = element_blank(),
      plot.title = element_text(face = "bold", size = 14),
      plot.subtitle = element_text(size = 12)
    )
  
  # Save the plot
  ggsave(file.path(output_dir, "change_bars.png"), plots$change_bars, width = 8, height = 6)
  
  # Plot 5: Small multiples of time threshold trends
  plots$small_multiples <- ggplot(yearly_long, aes(x = year, y = accessibility)) +
    geom_line(linewidth = 1, color = "steelblue") +
    geom_point(size = 2, color = "steelblue") +
    geom_smooth(method = "lm", se = FALSE, color = "darkred", linetype = "dashed") +
    facet_wrap(~ threshold, scales = "free_y") +
    scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
    scale_x_continuous(breaks = seq(min(yearly_access$year), max(yearly_access$year), by = 2)) +
    labs(
      title = "Accessibility Trends by Time Threshold (2013-2022)",
      x = "Year",
      y = "Accessibility (% of Population)"
    ) +
    theme_minimal() +
    theme(
      axis.text.x = element_text(angle = 45, hjust = 1),
      strip.background = element_rect(fill = "lightgray"),
      strip.text = element_text(face = "bold"),
      panel.grid.minor = element_blank(),
      plot.title = element_text(face = "bold", size = 14)
    )
  
  # Save the plot
  ggsave(file.path(output_dir, "small_multiples.png"), plots$small_multiples, width = 10, height = 6)
  
  # Plot 6: Create a combined dashboard using patchwork
  if (requireNamespace("patchwork", quietly = TRUE)) {
    combined_plot <- (plots$trend_lines + plots$normalized_trends) / 
      (plots$highlight_30min + plots$change_bars) +
      plot_annotation(
        title = "Accessibility Analysis Dashboard (2013-2022)",
        subtitle = "Multiple perspectives on the declining accessibility trends",
        caption = "Data source: Access_Data.csv",
        theme = theme(
          plot.title = element_text(size = 18, face = "bold"),
          plot.subtitle = element_text(size = 14),
          plot.caption = element_text(size = 10, hjust = 1)
        )
      )
    
    # Save the combined plot
    ggsave(file.path(output_dir, "accessibility_dashboard.png"), combined_plot, 
           width = 16, height = 12)
    
    plots$dashboard <- combined_plot
  }
  
  # Create an animated plot if gganimate is available
  if (requireNamespace("gganimate", quietly = TRUE)) {
    # Prepare data for animation
    yearly_long$year_f <- as.factor(yearly_long$year)
    
    anim_plot <- ggplot(yearly_long, aes(x = threshold, y = accessibility, fill = threshold)) +
      geom_col() +
      geom_text(aes(label = scales::percent(accessibility, accuracy = 0.1)),
                vjust = -0.5, size = 3.5) +
      scale_fill_viridis_d(option = "plasma", end = 0.9) +
      scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
      labs(
        title = "Accessibility by Time Threshold",
        subtitle = "Year: {closest_state}",
        x = NULL,
        y = "Accessibility (% of Population)"
      ) +
      theme_minimal() +
      theme(
        legend.position = "none",
        plot.title = element_text(face = "bold", size = 14),
        plot.subtitle = element_text(size = 12),
        axis.text.x = element_text(size = 12)
      ) +
      transition_states(
        year,
        transition_length = 2,
        state_length = 1
      ) +
      ease_aes('cubic-in-out')
    
    # Save the animation
    anim_save(file.path(output_dir, "accessibility_animation.gif"), anim_plot, 
              width = 8, height = 6, units = "in", res = 150, fps = 5)
  }
  
  return(plots)
}

#' Generate a side-by-side comparison of different years
#' 
#' @param data_file Path to the Access_Data.csv file
#' @param years_to_compare Vector of years to compare
#' @param output_dir Directory to save output files
#' 
#' @return A comparison plot
compare_years <- function(data_file = "Access_Data.csv",
                          years_to_compare = c(2013, 2022),
                          output_dir = getwd()) {
  
  # Read and process data
  access_data <- readr::read_csv(data_file, show_col_types = FALSE)
  
  # Extract percentages from accessibility columns
  access_data <- access_data %>%
    dplyr::mutate(across(
      .cols = starts_with("access_"),
      .fns = ~as.numeric(gsub(".*\\(([0-9.]+)%\\).*", "\\1", .)) / 100,
      .names = "{.col}_percent"
    ))
  
  # Filter to selected years
  filtered_data <- access_data %>%
    dplyr::filter(year %in% years_to_compare)
  
  # Aggregate by year
  year_summaries <- filtered_data %>%
    dplyr::group_by(year) %>%
    dplyr::summarize(
      access_30min = mean(access_30min_percent, na.rm = TRUE),
      access_60min = mean(access_60min_percent, na.rm = TRUE),
      access_120min = mean(access_120min_percent, na.rm = TRUE),
      access_180min = mean(access_180min_percent, na.rm = TRUE),
      .groups = "drop"
    ) %>%
    tidyr::pivot_longer(
      cols = starts_with("access_"),
      names_to = "threshold",
      values_to = "accessibility"
    ) %>%
    dplyr::mutate(
      threshold = factor(
        case_when(
          threshold == "access_30min" ~ "30-minute",
          threshold == "access_60min" ~ "60-minute",
          threshold == "access_120min" ~ "120-minute",
          threshold == "access_180min" ~ "180-minute"
        ),
        levels = c("30-minute", "60-minute", "120-minute", "180-minute")
      ),
      year = as.factor(year)
    )
  
  # Create comparison plot
  comparison_plot <- ggplot(year_summaries, 
                            aes(x = threshold, y = accessibility, fill = year)) +
    geom_bar(stat = "identity", position = "dodge") +
    geom_text(aes(label = scales::percent(accessibility, accuracy = 0.1)),
              position = position_dodge(width = 0.9),
              vjust = -0.5, size = 3.5) +
    scale_fill_brewer(palette = "Set1") +
    scale_y_continuous(
      labels = scales::percent_format(accuracy = 1),
      limits = c(0, max(year_summaries$accessibility) * 1.1)
    ) +
    labs(
      title = paste("Comparison of Accessibility:", 
                    paste(years_to_compare, collapse = " vs. ")),
      subtitle = "Decline is most pronounced in shorter travel times",
      x = "Time Threshold",
      y = "Accessibility (% of Population)",
      fill = "Year"
    ) +
    theme_minimal() +
    theme(
      legend.position = "top",
      plot.title = element_text(face = "bold", size = 14),
      plot.subtitle = element_text(size = 12),
      axis.text.x = element_text(size = 12)
    )
  
  # Save the plot
  ggsave(file.path(output_dir, "year_comparison.png"), comparison_plot, width = 10, height = 6)
  
  # Calculate percentage changes
  changes <- year_summaries %>%
    dplyr::group_by(threshold) %>%
    dplyr::summarize(
      first_value = accessibility[year == min(years_to_compare)],
      last_value = accessibility[year == max(years_to_compare)],
      abs_change = last_value - first_value,
      pct_change = (abs_change / first_value) * 100,
      .groups = "drop"
    )
  
  # Save changes
  write.csv(changes, file.path(output_dir, "accessibility_changes.csv"), row.names = FALSE)
  
  return(list(
    comparison_plot = comparison_plot,
    changes = changes
  ))
}

#' Run all visualizations
#' @param data_file Path to the Access_Data.csv file
#' @param output_dir Directory to save output files
#' @return A list containing visualization results
run_visualization_analysis <- function(data_file = "Access_Data.csv", 
                                       output_dir = "results/visualizations") {
  # Create all standard visualizations
  visualizations <- visualize_accessibility_trends(data_file, output_dir)
  
  # Create year comparison
  comparison <- compare_years(data_file, c(2013, 2022), output_dir)
  
  # Return combined results
  return(list(
    visualizations = visualizations,
    comparison = comparison
  ))
}
```

```{r}
#' @title Compare Accessibility Between Years With Trend Analysis
#' @description Creates a side-by-side comparison of accessibility metrics between
#'   selected years, highlighting the changes over time with statistical significance.
#' 
#' @param data_file Path to the CSV file containing accessibility data
#' @param years_to_compare Vector of years to compare (typically first and last)
#' @param output_dir Directory to save output files
#' @param verbose Logical indicating whether to print detailed logging information
#' 
#' @return A list containing the comparison plot and change metrics with statistical analysis
#'
#' @importFrom assertthat assert_that is_scalar
#' @importFrom logger log_info log_debug log_error log_warn
#' @importFrom dplyr filter mutate group_by summarize ungroup select left_join
#' @importFrom tidyr pivot_longer pivot_wider
#' @importFrom ggplot2 ggplot aes geom_bar position_dodge scale_fill_brewer 
#' @importFrom ggplot2 scale_y_continuous labs theme_minimal theme geom_text geom_segment
#' @importFrom readr read_csv write_csv
#' @importFrom scales percent_format percent
compare_years <- function(data_file = "access_by_group.csv",
                          years_to_compare = NULL,
                          output_dir = getwd(),
                          verbose = TRUE) {
  # Setup logger configuration
  logger::log_threshold(if(verbose) logger::INFO else logger::WARN)
  
  # Input validation
  assertthat::assert_that(
    assertthat::is.string(data_file),
    assertthat::is.string(output_dir),
    is.logical(verbose)
  )
  
  logger::log_info("Starting year comparison analysis with trend analysis")
  logger::log_info("Data file: {data_file}")
  logger::log_info("Output directory: {output_dir}")
  
  # Create output directory if it doesn't exist
  if (!dir.exists(output_dir)) {
    tryCatch({
      dir.create(output_dir, recursive = TRUE)
      logger::log_info("Created output directory: {output_dir}")
    }, error = function(e) {
      logger::log_error("Failed to create output directory: {e$message}")
      stop("Cannot create output directory: ", e$message, call. = FALSE)
    })
  }
  
  # Read and process data
  logger::log_info("Reading data from {data_file}")
  access_data <- readr::read_csv(data_file, show_col_types = FALSE)
  logger::log_debug("Successfully read {nrow(access_data)} rows of data")
  
  # Get all years for regression analysis
  all_years <- sort(unique(access_data$year))
  logger::log_info("Found data for years: {paste(all_years, collapse=', ')}")
  
  # Determine years to compare if not specified
  if (is.null(years_to_compare)) {
    years_to_compare <- c(min(all_years), max(all_years))
    logger::log_info("Years not specified, using first and last: {paste(years_to_compare, collapse=', ')}")
  }
  
  # Check against year column
  assertthat::assert_that(
    all(years_to_compare %in% all_years),
    msg = "All specified years must exist in the data"
  )
  
  logger::log_info("Comparing years: {paste(years_to_compare, collapse=', ')}")
  
  # Use total category if available
  if ("total" %in% access_data$category) {
    filtered_data <- dplyr::filter(
      access_data, 
      category == "total"
    )
    logger::log_info("Using 'total' category from data")
  } else if (any(grepl("^total_", access_data$category))) {
    # Use the first total_* category if no exact total
    total_cat <- grep("^total_", access_data$category, value = TRUE)[1]
    filtered_data <- dplyr::filter(
      access_data, 
      category == total_cat
    )
    logger::log_info("Using '{total_cat}' category as proxy for total")
  } else {
    # If no total category exists, use all data and warn
    filtered_data <- access_data
    logger::log_warn("No 'total' category found. Using all categories - results may be skewed.")
  }
  
  # Define time thresholds based on the actual range values in the data
  # Looking at the sample data, these appear to be 1800, 3600, 7200, 10800 seconds
  # which correspond to 30, 60, 120, 180 minutes
  unique_ranges <- sort(unique(filtered_data$range))
  logger::log_info("Found range values: {paste(unique_ranges, collapse=', ')}")
  
  # Convert ranges to minutes for labels
  range_minutes <- unique_ranges / 60
  standard_labels <- paste0(range_minutes, "-minute")
  
  # Create mapping for standardized labels
  range_mapping <- data.frame(
    range = unique_ranges,
    minutes = range_minutes,
    time_threshold = standard_labels
  )
  
  logger::log_info("Using time thresholds: {paste(standard_labels, collapse=', ')}")
  
  # Prepare data with proper time thresholds
  processed_data <- filtered_data %>%
    dplyr::left_join(range_mapping, by = "range") %>%
    dplyr::mutate(
      # Ensure time_threshold is properly ordered
      time_threshold = factor(
        time_threshold,
        levels = standard_labels
      )
    )
  
  # Group data by year and threshold for all years
  logger::log_info("Aggregating data by year and time threshold for all years")
  all_years_summary <- processed_data %>%
    dplyr::group_by(year, time_threshold) %>%
    dplyr::summarize(
      accessibility = mean(percent / 100, na.rm = TRUE),
      .groups = "drop"
    )
  
  # Perform regression analysis for each threshold
  logger::log_info("Performing regression analysis for each time threshold")
  
  regression_results <- data.frame()
  
  for (threshold in levels(processed_data$time_threshold)) {
    threshold_data <- all_years_summary %>% 
      dplyr::filter(time_threshold == threshold)
    
    # Run linear regression
    lm_result <- tryCatch({
      lm(accessibility ~ year, data = threshold_data)
    }, error = function(e) {
      logger::log_warn("Regression failed for {threshold}: {e$message}")
      return(NULL)
    })
    
    if (!is.null(lm_result)) {
      # Extract regression statistics
      coef_summary <- summary(lm_result)
      slope <- coef_summary$coefficients[2, 1]  # Coefficient (change per year)
      p_value <- coef_summary$coefficients[2, 4]  # p-value for slope
      r_squared <- coef_summary$r.squared
      
      regression_results <- rbind(regression_results, data.frame(
        time_threshold = threshold,
        slope = slope,
        slope_percent = slope * 100,  # Convert to percentage
        p_value = p_value,
        r_squared = r_squared,
        significance = dplyr::case_when(
          p_value < 0.001 ~ "***",
          p_value < 0.01 ~ "**",
          p_value < 0.05 ~ "*",
          TRUE ~ "ns"
        )
      ))
    }
  }
  
  # Filter to selected years for the bar chart
  year_summaries <- all_years_summary %>%
    dplyr::filter(year %in% years_to_compare) %>%
    # Ensure year is a factor for plotting
    dplyr::mutate(
      year = as.factor(year)
    )
  
  # Calculate percent change between selected years
  logger::log_info("Calculating percent changes between selected years")
  
  # Prepare data for the comparison
  change_data <- data.frame()
  
  for (threshold in levels(processed_data$time_threshold)) {
    threshold_data <- year_summaries %>% 
      dplyr::filter(time_threshold == threshold)
    
    # Get values for first and last years
    first_year_val <- threshold_data$accessibility[threshold_data$year == min(years_to_compare)]
    last_year_val <- threshold_data$accessibility[threshold_data$year == max(years_to_compare)]
    
    if (length(first_year_val) > 0 && length(last_year_val) > 0) {
      abs_change <- last_year_val - first_year_val
      pct_change <- (abs_change / first_year_val) * 100
      
      change_data <- rbind(change_data, data.frame(
        time_threshold = threshold,
        first_year = min(years_to_compare),
        last_year = max(years_to_compare),
        first_value = first_year_val,
        last_value = last_year_val,
        abs_change = abs_change,
        pct_change = pct_change
      ))
    }
  }
  
  # Join with regression results
  change_data <- change_data %>%
    dplyr::left_join(
      regression_results %>% dplyr::select(time_threshold, p_value, significance),
      by = "time_threshold"
    ) %>%
    # Order by standard time thresholds
    dplyr::mutate(
      time_threshold = factor(time_threshold, levels = standard_labels)
    ) %>%
    dplyr::arrange(time_threshold)
  
  # Create comparison plot with percent change annotations and significance
  logger::log_info("Creating enhanced comparison plot with trend significance")
  
  # Get position for dodged bars
  dodge_width <- 0.9
  position_dodge_obj <- ggplot2::position_dodge(width = dodge_width)
  
  # Create the enhanced comparison plot
  comparison_plot <- ggplot2::ggplot(
    year_summaries, 
    ggplot2::aes(x = time_threshold, y = accessibility, fill = year)
  ) +
    # Add bars
    ggplot2::geom_bar(stat = "identity", position = position_dodge_obj) +
    # Add percentage values on bars
    ggplot2::geom_text(
      ggplot2::aes(
        label = scales::percent(accessibility, accuracy = 0.1)
      ),
      position = position_dodge_obj,
      vjust = -0.5, 
      size = 3.5
    )
  
  # Calculate positions for connecting lines and text
  segment_data <- change_data %>%
    dplyr::mutate(
      x_start = as.numeric(time_threshold) - 0.25,
      x_end = as.numeric(time_threshold) + 0.25
    )
  
  # Add connecting lines
  comparison_plot <- comparison_plot +
    ggplot2::geom_segment(
      data = segment_data,
      mapping = ggplot2::aes(
        x = x_start,
        xend = x_end,
        y = first_value, 
        yend = last_value
      ),
      inherit.aes = FALSE,
      linewidth = 0.8,
      color = "black",
      alpha = 0.6,
      linetype = "dashed"
    )
  
  # Add percent change annotation with significance
  label_data <- segment_data %>%
    dplyr::mutate(
      y_pos = pmax(first_value, last_value) * 1.05,
      sig_label = ifelse(is.na(significance), "", significance),
      label = sprintf("%+.1f%% %s", pct_change, sig_label)
    )
  
  comparison_plot <- comparison_plot +
    ggplot2::geom_text(
      data = label_data,
      mapping = ggplot2::aes(
        x = time_threshold,
        y = y_pos,
        label = label
      ),
      inherit.aes = FALSE,
      color = ifelse(label_data$pct_change < 0, "red", "green4"),
      fontface = "bold"
    ) +
    # Apply styling
    ggplot2::scale_fill_brewer(palette = "Set1") +
    ggplot2::scale_y_continuous(
      labels = scales::percent_format(accuracy = 1),
      limits = c(0, max(year_summaries$accessibility) * 1.15)
    ) +
    ggplot2::labs(
      title = paste("Comparison of Accessibility:", 
                  paste(years_to_compare, collapse = " vs. ")),
      subtitle = "Changes in accessibility across time thresholds with statistical significance",
      caption = "Significance codes: *** p<0.001, ** p<0.01, * p<0.05, ns p≥0.05",
      x = "Time Threshold",
      y = "Accessibility (% of Population)",
      fill = "Year"
    ) +
    ggplot2::theme_minimal() +
    ggplot2::theme(
      legend.position = "top",
      plot.title = ggplot2::element_text(face = "bold", size = 14),
      plot.subtitle = ggplot2::element_text(size = 12),
      axis.text.x = ggplot2::element_text(size = 12, angle = 45, hjust = 1),
      plot.caption = ggplot2::element_text(size = 10, hjust = 1)
    )
  
  # Save the plot
  plot_path <- file.path(output_dir, "year_comparison.png")
  logger::log_info("Saving comparison plot to {plot_path}")
  ggplot2::ggsave(plot_path, comparison_plot, width = 10, height = 6)
  
  # Create a time series plot with trend lines and p-values
  logger::log_info("Creating time series plot with trend lines and p-values")
  
  # Prepare p-value labels for the plot
  p_value_labels <- regression_results %>%
    dplyr::mutate(
      label = sprintf("Slope: %.2f%% per year\np = %.4f %s", 
                     slope_percent, p_value, significance)
    )
  
  # Ensure year is numeric for time series plotting
  time_series_data <- all_years_summary %>%
    dplyr::mutate(year = as.numeric(year))
  
  # Get maximum y-position for each threshold for label placement
  label_positions <- time_series_data %>%
    dplyr::group_by(time_threshold) %>%
    dplyr::summarize(
      y_pos = min(accessibility) * 0.95,  # Place near bottom
      x_pos = mean(year)  # Place in middle of x-axis
    )
  
  # Join labels with positions
  p_value_labels <- p_value_labels %>%
    dplyr::left_join(label_positions, by = "time_threshold")
  
  time_series_plot <- ggplot2::ggplot(
    time_series_data, 
    ggplot2::aes(x = year, y = accessibility, color = time_threshold, group = time_threshold)
  ) +
    ggplot2::geom_point(size = 2) +
    ggplot2::geom_line(linewidth = 0.8) +
    ggplot2::geom_smooth(
      method = "lm", 
      se = TRUE, 
      alpha = 0.2,
      linewidth = 1
    ) +
    # Add p-value labels to each trend line
    ggplot2::geom_text(
      data = p_value_labels,
      mapping = ggplot2::aes(
        x = x_pos,
        y = y_pos,
        label = label,
        color = time_threshold
      ),
      hjust = 0.5,
      vjust = 0,
      size = 3,
      fontface = "bold",
      inherit.aes = FALSE
    ) +
    ggplot2::scale_color_viridis_d(option = "plasma", end = 0.9) +
    ggplot2::scale_y_continuous(labels = scales::percent_format()) +
    ggplot2::labs(
      title = "Accessibility Trends Over Time (2013-2022)",
      subtitle = "Linear trends with 95% confidence intervals and significance",
      caption = "Significance codes: *** p<0.001, ** p<0.01, * p<0.05, ns p≥0.05",
      x = "Year",
      y = "Accessibility (% of Population)",
      color = "Time Threshold"
    ) +
    ggplot2::theme_minimal() +
    ggplot2::theme(
      legend.position = "right",
      plot.title = ggplot2::element_text(face = "bold", size = 14),
      plot.subtitle = ggplot2::element_text(size = 12),
      plot.caption = ggplot2::element_text(size = 10, hjust = 1)
    )
  
  # Save the time series plot
  time_series_path <- file.path(output_dir, "accessibility_time_series.png")
  logger::log_info("Saving time series plot to {time_series_path}")
  ggplot2::ggsave(time_series_path, time_series_plot, width = 10, height = 6)
  
  # Save changes data with significance
  changes_path <- file.path(output_dir, "year_comparison_changes.csv")
  logger::log_info("Saving changes data with significance to {changes_path}")
  readr::write_csv(
    dplyr::left_join(
      change_data,
      regression_results,
      by = "time_threshold"
    ),
    changes_path
  )
  
  logger::log_info("Year comparison analysis complete")
  
  return(list(
    comparison_plot = comparison_plot,
    time_series_plot = time_series_plot,
    changes = change_data,
    regression_results = regression_results
  ))
}
```


```{r, fig.width=10, fig.height=6, include = TRUE}
yearbyyear <- compare_years(
  data_file = "data/Walker_data/access_by_group.csv",
  years_to_compare = c(2013, 2022),  
  output_dir = "figures",
  verbose = TRUE
); yearbyyear

```

## Interpretation of Visualization Results

The visualizations reveal several key findings:

1. There is a consistent decline in accessibility across all time thresholds from 2013 to 2022.

2. The decline is most pronounced for shorter travel times (30-minute threshold), with approximately a [X]% decrease over the study period.

3. The normalized trends show that accessibility at the 30-minute threshold has declined at a faster rate than longer travel times.

4. The comparison between 2013 and 2022 highlights the widening gap in accessibility, particularly for populations within short drive times of gynecologic oncologists.

These findings suggest that access to gynecologic oncology care has become more geographically concentrated over time, potentially exacerbating disparities for populations in areas with already limited access.

# Visualizing Accessibility: 1031 Function
```{r}
#' @title Visualize Accessibility Trends
#' @description Creates comprehensive visualizations of accessibility trends from 
#'   demographic data. This function handles data with columns including year, range, 
#'   category, count, total, and percent.
#' 
#' @param data_file Path to the CSV file containing accessibility data
#' @param output_dir Directory to save output files
#' @param time_ranges Vector of time ranges to analyze (in minutes)
#' @param verbose Logical indicating whether to print detailed logging information
#' 
#' @return A list containing all generated plot objects
#'
#' @importFrom assertthat assert_that is_scalar
#' @importFrom logger log_info log_debug log_error log_warn
#' @importFrom dplyr filter mutate group_by summarize ungroup across select arrange
#' @importFrom dplyr pull first n case_when desc rename
#' @importFrom tidyr pivot_longer pivot_wider
#' @importFrom ggplot2 ggplot aes geom_line geom_point geom_smooth scale_color_viridis_d
#' @importFrom ggplot2 scale_y_continuous scale_x_continuous labs theme_minimal theme
#' @importFrom ggplot2 element_text element_blank element_rect facet_wrap geom_col
#' @importFrom ggplot2 geom_hline geom_text ggsave geom_errorbar
#' @importFrom scales percent_format percent
#' @importFrom readr read_csv
#' @importFrom gghighlight gghighlight
#' @importFrom stringr str_c
#'
#' @examples
#' # Example 1: Basic usage with default parameters
#' accessibility_plots <- visualize_accessibility_trends(
#'   data_file = "data/access_by_group.csv",
#'   output_dir = "figures",
#'   time_ranges = c(30, 60, 120, 180),
#'   verbose = TRUE
#' )
#' # Shows comprehensive visualizations with detailed logging
#' 
#' # Example 2: Analyze only specific time ranges
#' accessibility_plots <- visualize_accessibility_trends(
#'   data_file = "data/access_by_group.csv",
#'   output_dir = "figures/selected_ranges",
#'   time_ranges = c(30, 60),
#'   verbose = FALSE
#' )
#' # Creates visualizations focusing only on 30 and 60 minute ranges
#' 
#' # Example 3: Saving to a custom directory with minimal output
#' accessibility_plots <- visualize_accessibility_trends(
#'   data_file = "path/to/custom_data.csv",
#'   output_dir = "reports/2025_analysis/figures",
#'   time_ranges = c(30, 60, 120, 180),
#'   verbose = FALSE
#' )
#' # Silently processes data and saves visualizations to the specified directory
visualize_accessibility_trends <- function(data_file = "access_by_group.csv", 
                                         output_dir = getwd(),
                                         time_ranges = c(30, 60, 120, 180),
                                         verbose = TRUE) {
  # Setup logger configuration
  logger::log_threshold(if(verbose) logger::INFO else logger::WARN)
  
  # Input validation
  assertthat::assert_that(
    assertthat::is.string(data_file),
    assertthat::is.string(output_dir),
    is.numeric(time_ranges),
    is.logical(verbose)
  )
  
  logger::log_info("Starting visualization of accessibility trends")
  logger::log_info("Data file: {data_file}")
  logger::log_info("Output directory: {output_dir}")
  logger::log_info("Time ranges to analyze: {paste(time_ranges, collapse = ', ')}")
  
  # Create helper functions
  prepare_data <- function(data_file) {
    logger::log_info("Reading data from {data_file}")
    
    # Read the data file
    tryCatch({
      accessibility_data <- readr::read_csv(data_file, show_col_types = FALSE)
      logger::log_info("Successfully read {nrow(accessibility_data)} rows of data")
      logger::log_debug("Data columns: {paste(names(accessibility_data), collapse = ', ')}")
    }, error = function(e) {
      logger::log_error("Failed to read data file: {e$message}")
      stop("Cannot read data file: ", e$message, call. = FALSE)
    })
    
    # Verify required columns exist
    required_cols <- c("year", "range", "percent", "category")
    assertthat::assert_that(
      all(required_cols %in% names(accessibility_data)),
      msg = stringr::str_c("Data must contain columns: ", 
                         paste(required_cols, collapse = ", "))
    )
    
    # Convert range values to actual minutes
    # First check if range values are in seconds (over 1000)
    logger::log_info("Converting range values to appropriate time units")
    if(max(accessibility_data$range, na.rm = TRUE) > 1000) {
      # Convert seconds to minutes
      accessibility_data <- dplyr::mutate(
        accessibility_data,
        range_minutes = as.numeric(range) / 60  # Convert seconds to minutes
      )
      logger::log_info("Converted range from seconds to minutes")
    } else {
      # Range is already in minutes
      accessibility_data <- dplyr::mutate(
        accessibility_data,
        range_minutes = as.numeric(range)
      )
      logger::log_info("Range values already in minutes")
    }
    
    # Filter for "total" category to get overall accessibility
    logger::log_info("Filtering data for relevant categories")
    if("total" %in% accessibility_data$category) {
      filtered_data <- dplyr::filter(accessibility_data, category == "total")
      logger::log_info("Using 'total' category from data")
    } else if(any(grepl("^total_", accessibility_data$category))) {
      # If no exact "total" category, use the first total_* category
      total_cat <- grep("^total_", accessibility_data$category, value = TRUE)[1]
      filtered_data <- dplyr::filter(accessibility_data, category == total_cat)
      logger::log_info("Using '{total_cat}' category as proxy for total")
    } else {
      # If no total category exists, use all data and warn
      filtered_data <- accessibility_data
      logger::log_warn("No 'total' category found. Using all data - results may be skewed.")
    }
    
    # Map to standard time thresholds
    logger::log_info("Mapping data ranges to standard time thresholds")
    
    # Create a function to map range to the closest standard time threshold
    map_to_threshold <- function(range_val) {
      closest_threshold <- time_ranges[which.min(abs(time_ranges - range_val))]
      return(paste0(closest_threshold, "-minute"))
    }
    
    # Apply mapping and create standard threshold labels
    accessibility_mapped <- filtered_data %>%
      dplyr::mutate(
        # Map each range value to the closest standard threshold
        time_threshold = sapply(range_minutes, map_to_threshold),
        # Ensure threshold is a properly ordered factor
        time_threshold = factor(
          time_threshold,
          levels = paste0(sort(time_ranges), "-minute")
        ),
        percent_value = percent / 100  # Convert to decimal for calculations
      )
    
    # Check if we have data for all years and thresholds
    years_available <- sort(unique(accessibility_mapped$year))
    logger::log_info("Years available in data: {paste(years_available, collapse = ', ')}")
    
    thresholds_available <- levels(accessibility_mapped$time_threshold)
    logger::log_info("Time thresholds available: {paste(thresholds_available, collapse = ', ')}")
    
    return(accessibility_mapped)
  }
  
  create_summary_data <- function(accessibility_data) {
    logger::log_info("Creating yearly summary statistics")
    
    # Aggregate data by year and time threshold
    yearly_summary <- accessibility_data %>%
      dplyr::group_by(year, time_threshold) %>%
      dplyr::summarize(
        avg_accessibility = mean(percent_value, na.rm = TRUE),
        sd_accessibility = sd(percent_value, na.rm = TRUE),  # Add standard deviation for error bars
        n_observations = n(),
        se_accessibility = sd_accessibility / sqrt(n_observations),  # Standard error
        .groups = "drop"
      )
    
    logger::log_debug("Created yearly summary with {nrow(yearly_summary)} rows")
    
    # Calculate percent changes from first year to last
    first_year <- min(yearly_summary$year)
    last_year <- max(yearly_summary$year)
    
    logger::log_info("Calculating changes from {first_year} to {last_year}")
    
    # Get first and last year data
    first_year_data <- yearly_summary %>%
      dplyr::filter(year == first_year) %>%
      dplyr::select(time_threshold, first_value = avg_accessibility, 
                   first_sd = sd_accessibility, first_n = n_observations)
    
    last_year_data <- yearly_summary %>%
      dplyr::filter(year == last_year) %>%
      dplyr::select(time_threshold, last_value = avg_accessibility,
                   last_sd = sd_accessibility, last_n = n_observations)
    
    # Join and calculate changes with error margins
    change_summary <- dplyr::inner_join(first_year_data, last_year_data, by = "time_threshold") %>%
      dplyr::mutate(
        absolute_change = last_value - first_value,
        percent_change = (absolute_change / first_value) * 100,
        
        # Calculate standard error for the difference
        se_diff = sqrt((first_sd^2 / first_n) + (last_sd^2 / last_n)),
        
        # Calculate standard error for the percentage change
        se_percent = abs(100 * se_diff / first_value),
        
        # Calculate 95% confidence intervals for error bars
        lower_ci = percent_change - 1.96 * se_percent,
        upper_ci = percent_change + 1.96 * se_percent
      ) %>%
      # Ensure time thresholds are ordered correctly
      dplyr::mutate(
        time_threshold = factor(
          time_threshold,
          levels = paste0(sort(time_ranges), "-minute")
        )
      )
    
    logger::log_debug("Created change summary with {nrow(change_summary)} rows")
    
    # Create normalized data (starting from 100%)
    logger::log_info("Creating normalized trend data (base year = 100%)")
    
    normalized_data <- yearly_summary %>%
      dplyr::group_by(time_threshold) %>%
      dplyr::mutate(
        first_year_value = dplyr::first(avg_accessibility[year == first_year]),
        relative_value = (avg_accessibility / first_year_value) * 100
      ) %>%
      dplyr::ungroup()
    
    return(list(
      yearly_summary = yearly_summary,
      change_summary = change_summary,
      normalized_data = normalized_data
    ))
  }
  
  create_output_dir <- function(output_dir) {
    logger::log_info("Ensuring output directory exists: {output_dir}")
    if (!dir.exists(output_dir)) {
      tryCatch({
        dir.create(output_dir, recursive = TRUE)
        logger::log_info("Created output directory: {output_dir}")
      }, error = function(e) {
        logger::log_error("Failed to create output directory: {e$message}")
        stop("Cannot create output directory: ", e$message, call. = FALSE)
      })
    } else {
      logger::log_info("Output directory already exists")
    }
  }
  
  create_trend_plot <- function(yearly_summary, output_dir) {
    logger::log_info("Creating time series trend plot")
    
    # Ensure year is treated as a factor for proper plotting
    yearly_summary <- yearly_summary %>%
      dplyr::mutate(year_factor = as.factor(year))
    
    trend_plot <- ggplot2::ggplot(
      yearly_summary, 
      ggplot2::aes(x = year_factor, y = avg_accessibility, color = time_threshold, group = time_threshold)
    ) +
      ggplot2::geom_point(size = 3) +
      ggplot2::geom_line(linewidth = 1) +
      ggplot2::geom_smooth(method = "lm", se = FALSE, linetype = "dashed") +
      ggplot2::scale_color_viridis_d(option = "plasma", end = 0.9) +
      ggplot2::scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
      ggplot2::labs(
        title = paste0("Accessibility Trends (", 
                     min(yearly_summary$year), "-", 
                     max(yearly_summary$year), ")"),
        subtitle = "Trends across different time thresholds",
        x = "Year",
        y = "Accessibility (% of Population)",
        color = "Time Threshold"
      ) +
      ggplot2::theme_minimal() +
      ggplot2::theme(
        axis.text.x = ggplot2::element_text(angle = 45, hjust = 1),
        legend.position = "right",
        panel.grid.minor = ggplot2::element_blank(),
        plot.title = ggplot2::element_text(face = "bold", size = 14),
        plot.subtitle = ggplot2::element_text(size = 12)
      )
    
    plot_path <- file.path(output_dir, "trend_lines.png")
    logger::log_info("Saving trend plot to {plot_path}")
    ggplot2::ggsave(plot_path, trend_plot, width = 10, height = 6)
    
    return(trend_plot)
  }
  
  create_highlight_plot <- function(yearly_summary, change_summary, output_dir) {
    logger::log_info("Creating highlighted threshold plot")
    
    # Ensure year is treated as a factor
    yearly_summary <- yearly_summary %>%
      dplyr::mutate(year_factor = as.factor(year))
    
    # Find the threshold with the largest negative change
    most_decline <- change_summary %>%
      dplyr::arrange(percent_change) %>%
      dplyr::slice(1) %>%
      dplyr::pull(time_threshold)
    
    logger::log_info("Most significant decline in {most_decline} threshold: {round(change_summary$percent_change[change_summary$time_threshold == most_decline], 1)}%")
    
    highlight_plot <- ggplot2::ggplot(
      yearly_summary, 
      ggplot2::aes(x = year_factor, y = avg_accessibility, color = time_threshold, group = time_threshold)
    ) +
      ggplot2::geom_line(linewidth = 1.5) +
      ggplot2::geom_point(size = 3) +
      gghighlight::gghighlight(
        time_threshold == most_decline, 
        unhighlighted_params = list(colour = "gray80")
      ) +
      ggplot2::scale_color_viridis_d(option = "plasma", end = 0.9) +
      ggplot2::scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
      ggplot2::labs(
        title = paste0(most_decline, " Accessibility Shows Most Severe Decline"),
        subtitle = paste0(
          "Overall decrease of ", 
          round(change_summary$percent_change[change_summary$time_threshold == most_decline], 1), 
          "% from ", min(yearly_summary$year), " to ", max(yearly_summary$year)
        ),
        x = "Year",
        y = "Accessibility (% of Population)",
        color = "Time Threshold"
      ) +
      ggplot2::theme_minimal() +
      ggplot2::theme(
        axis.text.x = ggplot2::element_text(angle = 45, hjust = 1),
        legend.position = "none",
        panel.grid.minor = ggplot2::element_blank(),
        plot.title = ggplot2::element_text(face = "bold", size = 14),
        plot.subtitle = ggplot2::element_text(size = 12)
      )
    
    plot_path <- file.path(output_dir, "highlight_threshold.png")
    logger::log_info("Saving highlight plot to {plot_path}")
    ggplot2::ggsave(plot_path, highlight_plot, width = 8, height = 6)
    
    return(highlight_plot)
  }
  
  create_normalized_plot <- function(normalized_data, output_dir) {
    logger::log_info("Creating normalized trends plot")
    
    # Ensure year is treated as a factor
    normalized_data <- normalized_data %>%
      dplyr::mutate(year_factor = as.factor(year))
    
    normalized_plot <- ggplot2::ggplot(
      normalized_data, 
      ggplot2::aes(x = year_factor, y = relative_value, color = time_threshold, group = time_threshold)
    ) +
      ggplot2::geom_hline(yintercept = 100, linetype = "dashed", color = "gray50") +
      ggplot2::geom_line(linewidth = 1.2) +
      ggplot2::geom_point(size = 2.5) +
      ggplot2::scale_color_viridis_d(option = "plasma", end = 0.9) +
      ggplot2::scale_y_continuous(
        limits = function(x) c(min(x) - 5, 105),
        breaks = function(x) seq(floor(min(x) / 5) * 5, 105, by = 5),
        labels = function(x) paste0(x, "%")
      ) +
      ggplot2::labs(
        title = paste0("Relative Accessibility Changes (", min(normalized_data$year), " = 100%)"),
        subtitle = "Relative changes in accessibility across time thresholds",
        x = "Year",
        y = "Relative Accessibility",
        color = "Time Threshold"
      ) +
      ggplot2::theme_minimal() +
      ggplot2::theme(
        axis.text.x = ggplot2::element_text(angle = 45, hjust = 1),
        legend.position = "right",
        panel.grid.minor = ggplot2::element_blank(),
        plot.title = ggplot2::element_text(face = "bold", size = 14),
        plot.subtitle = ggplot2::element_text(size = 12)
      )
    
    plot_path <- file.path(output_dir, "normalized_trends.png")
    logger::log_info("Saving normalized plot to {plot_path}")
    ggplot2::ggsave(plot_path, normalized_plot, width = 10, height = 6)
    
    return(normalized_plot)
  }
  
  create_change_bars <- function(change_summary, output_dir) {
    logger::log_info("Creating change bars plot with error bars")
    
    # Ensure time thresholds are properly ordered
    change_summary <- change_summary %>%
      dplyr::mutate(
        time_threshold = factor(
          time_threshold,
          levels = paste0(sort(time_ranges), "-minute")
        )
      )
    
    change_plot <- ggplot2::ggplot(
      change_summary, 
      ggplot2::aes(x = time_threshold, y = percent_change, fill = time_threshold)
    ) +
      ggplot2::geom_col() +
      # Add error bars using the confidence intervals
      ggplot2::geom_errorbar(
        ggplot2::aes(ymin = lower_ci, ymax = upper_ci),
        width = 0.2,
        position = ggplot2::position_dodge(0.9)
      ) +
      ggplot2::geom_text(
        ggplot2::aes(
          label = sprintf("%.1f%%", percent_change),
          vjust = ifelse(percent_change < 0, 1.5, -0.5)
        ),
        color = ifelse(change_summary$percent_change < 0, "white", "black"),
        size = 4
      ) +
      ggplot2::scale_fill_viridis_d(option = "plasma", end = 0.9) +
      ggplot2::labs(
        title = paste0("Percentage Change in Accessibility (", 
                     min(yearly_summary$year), "-", 
                     max(yearly_summary$year), ")"),
        subtitle = "Change in accessibility by time threshold (with 95% confidence intervals)",
        x = NULL,
        y = "Percentage Change",
        fill = "Time Threshold"
      ) +
      ggplot2::theme_minimal() +
      ggplot2::theme(
        axis.text.x = ggplot2::element_text(size = 12),
        legend.position = "none",
        panel.grid.minor = ggplot2::element_blank(),
        plot.title = ggplot2::element_text(face = "bold", size = 14),
        plot.subtitle = ggplot2::element_text(size = 12)
      )
    
    plot_path <- file.path(output_dir, "change_bars.png")
    logger::log_info("Saving change bars plot to {plot_path}")
    ggplot2::ggsave(plot_path, change_plot, width = 8, height = 6)
    
    return(change_plot)
  }
  
  create_small_multiples <- function(yearly_summary, output_dir) {
    logger::log_info("Creating small multiples plot")
    
    # Ensure year is treated as a factor
    yearly_summary <- yearly_summary %>%
      dplyr::mutate(year_factor = as.factor(year))
    
    multiples_plot <- ggplot2::ggplot(
      yearly_summary, 
      ggplot2::aes(x = year_factor, y = avg_accessibility, group = 1)
    ) +
      ggplot2::geom_line(linewidth = 1, color = "steelblue") +
      ggplot2::geom_point(size = 2, color = "steelblue") +
      ggplot2::geom_smooth(method = "lm", se = FALSE, color = "darkred", linetype = "dashed") +
      ggplot2::facet_wrap(~ time_threshold, scales = "free_y") +
      ggplot2::scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
      ggplot2::labs(
        title = paste0("Accessibility Trends by Time Threshold (", 
                     min(yearly_summary$year), "-", 
                     max(yearly_summary$year), ")"),
        x = "Year",
        y = "Accessibility (% of Population)"
      ) +
      ggplot2::theme_minimal() +
      ggplot2::theme(
        axis.text.x = ggplot2::element_text(angle = 45, hjust = 1),
        strip.background = ggplot2::element_rect(fill = "lightgray"),
        strip.text = ggplot2::element_text(face = "bold"),
        panel.grid.minor = ggplot2::element_blank(),
        plot.title = ggplot2::element_text(face = "bold", size = 14)
      )
    
    plot_path <- file.path(output_dir, "small_multiples.png")
    logger::log_info("Saving small multiples plot to {plot_path}")
    ggplot2::ggsave(plot_path, multiples_plot, width = 10, height = 6)
    
    return(multiples_plot)
  }
  
  create_dashboard <- function(all_plots, output_dir) {
    logger::log_info("Checking if patchwork package is available for dashboard creation")
    
    if (!requireNamespace("patchwork", quietly = TRUE)) {
      logger::log_warn("Patchwork package not available - skipping dashboard creation")
      return(NULL)
    }
    
    logger::log_info("Creating combined dashboard using patchwork")
    
    combined_plot <- (all_plots$trend_plot + all_plots$normalized_plot) / 
      (all_plots$highlight_plot + all_plots$change_plot) +
      patchwork::plot_annotation(
        title = "Accessibility Analysis Dashboard",
        subtitle = paste0("Multiple perspectives on accessibility trends (", 
                        min(yearly_summary$year), "-", 
                        max(yearly_summary$year), ")"),
        caption = paste0("Data source: ", data_file),
        theme = ggplot2::theme(
          plot.title = ggplot2::element_text(size = 18, face = "bold"),
          plot.subtitle = ggplot2::element_text(size = 14),
          plot.caption = ggplot2::element_text(size = 10, hjust = 1)
        )
      )
    
    dashboard_path <- file.path(output_dir, "accessibility_dashboard.png")
    logger::log_info("Saving dashboard to {dashboard_path}")
    ggplot2::ggsave(dashboard_path, combined_plot, width = 16, height = 12)
    
    return(combined_plot)
  }
  
  # Main execution flow
  create_output_dir(output_dir)
  
  # Process data
  accessibility_data <- prepare_data(data_file)
  
  # Create summary statistics
  summaries <- create_summary_data(accessibility_data)
  yearly_summary <- summaries$yearly_summary
  change_summary <- summaries$change_summary
  normalized_data <- summaries$normalized_data
  
  # Create all plots
  plots <- list()
  
  plots$trend_plot <- create_trend_plot(yearly_summary, output_dir)
  plots$highlight_plot <- create_highlight_plot(yearly_summary, change_summary, output_dir)
  plots$normalized_plot <- create_normalized_plot(normalized_data, output_dir)
  plots$change_plot <- create_change_bars(change_summary, output_dir)
  plots$small_multiples <- create_small_multiples(yearly_summary, output_dir)
  
  # Create dashboard if patchwork is available
  dashboard <- create_dashboard(plots, output_dir)
  if (!is.null(dashboard)) {
    plots$dashboard <- dashboard
  }
  
  # Save the summary data
  summary_path <- file.path(output_dir, "accessibility_changes.csv")
  logger::log_info("Saving summary data to {summary_path}")
  readr::write_csv(change_summary, summary_path)
  
  logger::log_info("Visualization process complete")
  return(plots)
}

#' @noRd
is_scalar <- function(x) {
  length(x) == 1 && !is.null(x)
}

#' @title Compare Accessibility Between Years
#' @description Creates a side-by-side comparison of accessibility metrics between
#'   selected years, highlighting the changes over time.
#' 
#' @param data_file Path to the CSV file containing accessibility data
#' @param years_to_compare Vector of years to compare (typically first and last)
#' @param output_dir Directory to save output files
#' @param verbose Logical indicating whether to print detailed logging information
#' 
#' @return A list containing the comparison plot and change metrics
#'
#' @importFrom assertthat assert_that is_scalar
#' @importFrom logger log_info log_debug log_error log_warn
#' @importFrom dplyr filter mutate group_by summarize ungroup select
#' @importFrom tidyr pivot_longer pivot_wider
#' @importFrom ggplot2 ggplot aes geom_bar position_dodge scale_fill_brewer 
#' @importFrom ggplot2 scale_y_continuous labs theme_minimal theme geom_text
#' @importFrom readr read_csv write_csv
#' @importFrom scales percent_format percent
#'
#' @examples
#' # Example 1: Basic comparison between earliest and latest years
#' comparison_results <- compare_years(
#'   data_file = "data/access_by_group.csv",
#'   years_to_compare = c(2013, 2022),
#'   output_dir = "figures",
#'   verbose = TRUE
#' )
#' # Creates comparison visualization between 2013 and 2022
#' 
#' # Example 2: Compare specific non-consecutive years
#' comparison_results <- compare_years(
#'   data_file = "data/access_by_group.csv",
#'   years_to_compare = c(2015, 2020),
#'   output_dir = "figures/specific_years",
#'   verbose = TRUE
#' )
#' # Compares accessibility between 2015 and 2020
#' 
#' # Example 3: Compare three different years with minimal output
#' comparison_results <- compare_years(
#'   data_file = "data/access_by_group.csv",
#'   years_to_compare = c(2013, 2018, 2022),
#'   output_dir = "reports/multi_year_comparison",
#'   verbose = FALSE
#' )
#' # Silently creates comparison between three specified years
compare_years <- function(data_file = "access_by_group.csv",
                        years_to_compare = NULL,
                        output_dir = getwd(),
                        verbose = TRUE) {
  # Setup logger configuration
  logger::log_threshold(if(verbose) logger::INFO else logger::WARN)
  
  # Input validation
  assertthat::assert_that(
    assertthat::is.string(data_file),
    assertthat::is.string(output_dir),
    is.logical(verbose)
  )
  
  logger::log_info("Starting year comparison analysis")
  logger::log_info("Data file: {data_file}")
  logger::log_info("Output directory: {output_dir}")
  
  # Create output directory if it doesn't exist
  if (!dir.exists(output_dir)) {
    tryCatch({
      dir.create(output_dir, recursive = TRUE)
      logger::log_info("Created output directory: {output_dir}")
    }, error = function(e) {
      logger::log_error("Failed to create output directory: {e$message}")
      stop("Cannot create output directory: ", e$message, call. = FALSE)
    })
  }
  
  # Read and process data
  logger::log_info("Reading data from {data_file}")
  access_data <- readr::read_csv(data_file, show_col_types = FALSE)
  logger::log_debug("Successfully read {nrow(access_data)} rows of data")
  
  # Verify required columns exist
  required_cols <- c("year", "range", "percent", "category")
  assertthat::assert_that(
    all(required_cols %in% names(access_data)),
    msg = stringr::str_c("Data must contain columns: ", 
                       paste(required_cols, collapse = ", "))
  )
  
  # Determine years to compare if not specified
  if (is.null(years_to_compare)) {
    years_available <- sort(unique(access_data$year))
    years_to_compare <- c(min(years_available), max(years_available))
    logger::log_info("Years not specified, using first and last: {paste(years_to_compare, collapse=', ')}")
  }
  
  # Fix: Check against year column, not range column
  assertthat::assert_that(
    all(years_to_compare %in% unique(access_data$year)),
    msg = "All specified years must exist in the data"
  )
  
  logger::log_info("Comparing years: {paste(years_to_compare, collapse=', ')}")
  
  # Filter to selected years and categories
  logger::log_info("Filtering data for relevant years and categories")
  
  # Use total category if available
  if ("total" %in% access_data$category) {
    filtered_data <- dplyr::filter(
      access_data, 
      year %in% years_to_compare,
      category == "total"
    )
    logger::log_info("Using 'total' category from data")
  } else if (any(grepl("^total_", access_data$category))) {
    # Use the first total_* category if no exact total
    total_cat <- grep("^total_", access_data$category, value = TRUE)[1]
    filtered_data <- dplyr::filter(
      access_data, 
      year %in% years_to_compare,
      category == total_cat
    )
    logger::log_info("Using '{total_cat}' category as proxy for total")
  } else {
    # If no total category exists, use all data and warn
    filtered_data <- dplyr::filter(access_data, year %in% years_to_compare)
    logger::log_warn("No 'total' category found. Using all categories - results may be skewed.")
  }
  
  # Convert range to minutes if needed
  if(max(filtered_data$range, na.rm = TRUE) > 1000) {
    logger::log_info("Converting range from seconds to minutes")
    filtered_data <- dplyr::mutate(
      filtered_data,
      range_minutes = range / 60,
      time_threshold = paste0(range_minutes, "-minute")
    )
  } else {
    filtered_data <- dplyr::mutate(
      filtered_data,
      range_minutes = range,
      time_threshold = paste0(range, "-minute")
    )
  }
  
  # Define standard time thresholds for ordering
  standard_thresholds <- paste0(sort(c(30, 60, 120, 180)), "-minute")
  
  # Group data by year and range
  logger::log_info("Aggregating data by year and time threshold")
  year_summaries <- filtered_data %>%
    # Map to standard thresholds if possible
    dplyr::mutate(
      standard_threshold = dplyr::case_when(
        range_minutes <= 30 ~ "30-minute",
        range_minutes <= 60 ~ "60-minute",
        range_minutes <= 120 ~ "120-minute",
        range_minutes <= 180 ~ "180-minute",
        TRUE ~ time_threshold
      ),
      # Ensure it's ordered correctly
      standard_threshold = factor(standard_threshold, levels = standard_thresholds)
    ) %>%
    dplyr::group_by(year, standard_threshold) %>%
    dplyr::summarize(
      accessibility = mean(percent / 100, na.rm = TRUE),
      .groups = "drop"
    ) %>%
    dplyr::mutate(year = as.factor(year))
  
  logger::log_debug("Created yearly summary with {nrow(year_summaries)} rows")
  
  # Create comparison plot
  logger::log_info("Creating comparison bar chart")
  
  comparison_plot <- ggplot2::ggplot(
    year_summaries, 
    ggplot2::aes(x = standard_threshold, y = accessibility, fill = year)
  ) +
    ggplot2::geom_bar(stat = "identity", position = ggplot2::position_dodge()) +
    ggplot2::geom_text(
      ggplot2::aes(
        label = scales::percent(accessibility, accuracy = 0.1)
      ),
      position = ggplot2::position_dodge(width = 0.9),
      vjust = -0.5, 
      size = 3.5
    ) +
    ggplot2::scale_fill_brewer(palette = "Set1") +
    ggplot2::scale_y_continuous(
      labels = scales::percent_format(accuracy = 1),
      limits = c(0, max(year_summaries$accessibility) * 1.1)
    ) +
    ggplot2::labs(
      title = paste("Comparison of Accessibility:", 
                  paste(years_to_compare, collapse = " vs. ")),
      subtitle = "Changes in accessibility across time thresholds",
      x = "Time Threshold",
      y = "Accessibility (% of Population)",
      fill = "Year"
    ) +
    ggplot2::theme_minimal() +
    ggplot2::theme(
      legend.position = "top",
      plot.title = ggplot2::element_text(face = "bold", size = 14),
      plot.subtitle = ggplot2::element_text(size = 12),
      axis.text.x = ggplot2::element_text(size = 12, angle = 45, hjust = 1)
    )
  
  # Save the plot
  plot_path <- file.path(output_dir, "year_comparison.png")
  logger::log_info("Saving comparison plot to {plot_path}")
  ggplot2::ggsave(plot_path, comparison_plot, width = 10, height = 6)
  
  # Calculate changes
  logger::log_info("Calculating changes between years")
  
  changes <- year_summaries %>%
    dplyr::group_by(standard_threshold) %>%
    dplyr::summarize(
      first_year = min(as.numeric(as.character(year))),
      last_year = max(as.numeric(as.character(year))),
      first_value = accessibility[year == as.character(first_year)],
      last_value = accessibility[year == as.character(last_year)],
      abs_change = last_value - first_value,
      pct_change = (abs_change / first_value) * 100,
      .groups = "drop"
    )
  
  # Save changes data
  changes_path <- file.path(output_dir, "year_comparison_changes.csv")
  logger::log_info("Saving changes data to {changes_path}")
  readr::write_csv(changes, changes_path)
  
  logger::log_info("Year comparison analysis complete")
  
  return(list(
    comparison_plot = comparison_plot,
    changes = changes
  ))
}

#' @title Run Comprehensive Accessibility Analysis
#' @description Runs both trend visualization and year comparison analysis on 
#'   accessibility data, creating a complete set of visualizations and metrics.
#' 
#' @param data_file Path to the CSV file containing accessibility data
#' @param output_dir Directory to save output files
#' @param time_ranges Vector of time ranges to analyze (in minutes)
#' @param years_to_compare Vector of years to compare in the year comparison plot
#' @param verbose Logical indicating whether to print detailed logging information
#' 
#' @return A list containing all visualization and analysis results
#'
#' @importFrom logger log_info log_debug log_error log_warn
#' @importFrom assertthat assert_that is_scalar
#'
#' @examples
#' # Example 1: Run full analysis with default parameters
#' analysis_results <- run_accessibility_analysis(
#'   data_file = "data/access_by_group.csv",
#'   output_dir = "figures/full_analysis",
#'   time_ranges = c(30, 60, 120, 180),
#'   years_to_compare = c(2013, 2022),
#'   verbose = TRUE
#' )
#' # Creates comprehensive analysis with detailed logging
#' 
#' # Example 2: Focus on specific time ranges and years
#' analysis_results <- run_accessibility_analysis(
#'   data_file = "data/access_by_group.csv",
#'   output_dir = "figures/focused_analysis",
#'   time_ranges = c(30, 60),
#'   years_to_compare = c(2015, 2020),
#'   verbose = TRUE
#' )
#' # Analysis focuses on 30 and 60 minute ranges, comparing 2015 to 2020
#' 
#' # Example 3: Silently run analysis for a custom data file
#' analysis_results <- run_accessibility_analysis(
#'   data_file = "path/to/custom_data.csv",
#'   output_dir = "reports/2025_analysis",
#'   time_ranges = c(30, 60, 120, 180),
#'   years_to_compare = NULL,
#'   verbose = FALSE
#' )
#' # Runs analysis without logging, using first and last years in the data
run_accessibility_analysis <- function(data_file = "access_by_group.csv",
                                     output_dir = "results/analysis",
                                     time_ranges = c(30, 60, 120, 180),
                                     years_to_compare = NULL,
                                     verbose = TRUE) {
  # Setup logger
  logger::log_threshold(if(verbose) logger::INFO else logger::WARN)
  
  # Input validation
  assertthat::assert_that(
    assertthat::is.string(data_file),
    assertthat::is.string(output_dir),
    is.numeric(time_ranges),
    is.logical(verbose)
  )
  
  logger::log_info("Starting comprehensive accessibility analysis")
  logger::log_info("Data file: {data_file}")
  logger::log_info("Output directory: {output_dir}")
  
  # Create trend visualizations directory
  trends_dir <- file.path(output_dir, "trends")
  logger::log_info("Creating trend visualizations in {trends_dir}")
  trend_visualizations <- visualize_accessibility_trends(
    data_file = data_file,
    output_dir = trends_dir,
    time_ranges = time_ranges,
    verbose = verbose
  )
  
  # Create year comparison directory
  comparison_dir <- file.path(output_dir, "comparisons")
  logger::log_info("Creating year comparisons in {comparison_dir}")
  year_comparison <- compare_years(
    data_file = data_file,
    years_to_compare = years_to_compare,
    output_dir = comparison_dir,
    verbose = verbose
  )
  
  logger::log_info("Comprehensive accessibility analysis complete")
  
  # Return combined results
  return(list(
    visualizations = trend_visualizations,
    comparison = year_comparison
  ))
}
```

```{r, include = TRUE}
# Install needed packages if not already installed
# install.packages(c("assertthat", "logger", "tidyverse", "ggplot2", "gghighlight"))

# Run the full analysis
analysis_results <- visualize_accessibility_trends(data_file = "data/Walker_data/access_by_group.csv", 
                                         output_dir = "figures",
                                         time_ranges = c(30, 60, 120, 180),
                                         verbose = TRUE); analysis_results
  
```

# Compare Accessibility Between Years With Trend Significance: 1228 Function
```{r}
#' @title Compare Accessibility Between Years With Trend Significance
#' @description Creates a side-by-side comparison of accessibility metrics between
#'   selected years, highlighting the changes over time with percent change indicators
#'   and trend significance.
#' 
#' @param data_file Path to the CSV file containing accessibility data
#' @param years_to_compare Vector of years to compare (typically first and last)
#' @param output_dir Directory to save output files
#' @param verbose Logical indicating whether to print detailed logging information
#' 
#' @return A list containing the comparison plot and change metrics
#'
#' @importFrom assertthat assert_that is_scalar
#' @importFrom logger log_info log_debug log_error log_warn
#' @importFrom dplyr filter mutate group_by summarize ungroup select
#' @importFrom tidyr pivot_longer pivot_wider
#' @importFrom ggplot2 ggplot aes geom_bar position_dodge scale_fill_brewer 
#' @importFrom ggplot2 scale_y_continuous labs theme_minimal theme geom_text geom_segment
#' @importFrom readr read_csv write_csv
#' @importFrom scales percent_format percent
compare_years <- function(data_file = "access_by_group.csv",
                          years_to_compare = NULL,
                          output_dir = getwd(),
                          verbose = TRUE) {
  # Setup logger configuration
  logger::log_threshold(if(verbose) logger::INFO else logger::WARN)
  
  # Input validation
  assertthat::assert_that(
    assertthat::is.string(data_file),
    assertthat::is.string(output_dir),
    is.logical(verbose)
  )
  
  logger::log_info("Starting year comparison analysis with trend significance")
  logger::log_info("Data file: {data_file}")
  logger::log_info("Output directory: {output_dir}")
  
  # Create output directory if it doesn't exist
  if (!dir.exists(output_dir)) {
    tryCatch({
      dir.create(output_dir, recursive = TRUE)
      logger::log_info("Created output directory: {output_dir}")
    }, error = function(e) {
      logger::log_error("Failed to create output directory: {e$message}")
      stop("Cannot create output directory: ", e$message, call. = FALSE)
    })
  }
  
  # Read and process data
  logger::log_info("Reading data from {data_file}")
  access_data <- readr::read_csv(data_file, show_col_types = FALSE)
  logger::log_debug("Successfully read {nrow(access_data)} rows of data")
  
  # Get all years for regression analysis
  all_years <- sort(unique(access_data$year))
  logger::log_info("Found data for years: {paste(all_years, collapse=', ')}")
  
  # Determine years to compare if not specified
  if (is.null(years_to_compare)) {
    years_to_compare <- c(min(all_years), max(all_years))
    logger::log_info("Years not specified, using first and last: {paste(years_to_compare, collapse=', ')}")
  }
  
  # Check against year column
  assertthat::assert_that(
    all(years_to_compare %in% all_years),
    msg = "All specified years must exist in the data"
  )
  
  logger::log_info("Comparing years: {paste(years_to_compare, collapse=', ')}")
  
  # Use total category if available
  if ("total" %in% access_data$category) {
    filtered_data <- dplyr::filter(
      access_data, 
      category == "total"
    )
    logger::log_info("Using 'total' category from data")
  } else if (any(grepl("^total_", access_data$category))) {
    # Use the first total_* category if no exact total
    total_cat <- grep("^total_", access_data$category, value = TRUE)[1]
    filtered_data <- dplyr::filter(
      access_data, 
      category == total_cat
    )
    logger::log_info("Using '{total_cat}' category as proxy for total")
  } else {
    # If no total category exists, use all data and warn
    filtered_data <- access_data
    logger::log_warn("No 'total' category found. Using all categories - results may be skewed.")
  }
  
  # Define standard time thresholds based on actual data
  unique_ranges <- sort(unique(filtered_data$range))
  
  # Convert range to minutes if needed
  logger::log_info("Processing time ranges")
  if(max(filtered_data$range, na.rm = TRUE) > 1000) {
    # Convert from seconds to minutes
    range_minutes <- unique_ranges / 60
    filtered_data <- filtered_data %>%
      dplyr::mutate(
        range_minutes = range / 60
      )
    logger::log_info("Converted range from seconds to minutes")
  } else {
    # Range already in minutes
    range_minutes <- unique_ranges
    filtered_data <- filtered_data %>%
      dplyr::mutate(
        range_minutes = range
      )
  }
  
  # Create time threshold labels
  standard_labels <- paste0(range_minutes, "-minute")
  logger::log_info("Using time thresholds: {paste(standard_labels, collapse=', ')}")
  
  # Create a mapping between range and threshold
  threshold_mapping <- data.frame(
    range = unique_ranges,
    time_threshold = standard_labels,
    stringsAsFactors = FALSE
  )
  
  # Join with threshold mapping
  processed_data <- filtered_data %>%
    dplyr::left_join(threshold_mapping, by = "range") %>%
    dplyr::mutate(
      time_threshold = factor(time_threshold, levels = standard_labels)
    )
  
  # Process data for all years for regression analysis
  all_years_data <- processed_data %>%
    dplyr::group_by(year, time_threshold) %>%
    dplyr::summarize(
      accessibility = mean(percent / 100, na.rm = TRUE),
      .groups = "drop"
    )
  
  # Perform regression analysis to get p-values
  logger::log_info("Performing regression analysis for trend significance")
  
  regression_results <- data.frame()
  
  for (threshold in levels(processed_data$time_threshold)) {
    # Extract data for this threshold across all years
    threshold_data <- all_years_data %>%
      dplyr::filter(time_threshold == threshold)
    
    if (nrow(threshold_data) >= 3) {  # Need at least 3 points for meaningful regression
      # Fit linear model
      model <- tryCatch({
        lm(accessibility ~ year, data = threshold_data)
      }, error = function(e) {
        logger::log_warn("Regression failed for {threshold}: {e$message}")
        return(NULL)
      })
      
      if (!is.null(model)) {
        # Extract p-value for the slope
        model_summary <- summary(model)
        slope <- model_summary$coefficients[2, 1]  # Coefficient for year
        p_value <- model_summary$coefficients[2, 4]  # p-value for year coefficient
        
        # Add to results
        regression_results <- rbind(regression_results, data.frame(
          time_threshold = threshold,
          slope = slope,
          p_value = p_value,
          significance = dplyr::case_when(
            p_value < 0.001 ~ "***",
            p_value < 0.01 ~ "**", 
            p_value < 0.05 ~ "*",
            TRUE ~ "ns"
          )
        ))
      }
    } else {
      logger::log_warn("Not enough data points for regression on {threshold}")
    }
  }
  
  # Filter to selected years for comparison
  year_summaries <- all_years_data %>%
    dplyr::filter(year %in% years_to_compare) %>%
    dplyr::mutate(year = as.factor(year))
  
  # Calculate percent change between selected years
  logger::log_info("Calculating percent changes between selected years")
  
  change_data <- data.frame()
  
  for (threshold in levels(processed_data$time_threshold)) {
    # Extract data for this threshold for the comparison years
    threshold_data <- year_summaries %>%
      dplyr::filter(time_threshold == threshold)
    
    first_year_val <- threshold_data$accessibility[threshold_data$year == min(years_to_compare)]
    last_year_val <- threshold_data$accessibility[threshold_data$year == max(years_to_compare)]
    
    if (length(first_year_val) > 0 && length(last_year_val) > 0) {
      abs_change <- last_year_val - first_year_val
      pct_change <- (abs_change / first_year_val) * 100
      
      change_data <- rbind(change_data, data.frame(
        time_threshold = threshold,
        first_year = min(years_to_compare),
        last_year = max(years_to_compare),
        first_value = first_year_val,
        last_value = last_year_val,
        abs_change = abs_change,
        pct_change = pct_change
      ))
    }
  }
  
  # Join with significance data
  if (nrow(regression_results) > 0) {
    change_data <- change_data %>%
      dplyr::left_join(
        regression_results %>% 
          dplyr::select(time_threshold, p_value, significance),
        by = "time_threshold"
      )
  }
  
  # Ensure proper ordering
  change_data <- change_data %>%
    dplyr::mutate(
      time_threshold = factor(time_threshold, levels = standard_labels)
    ) %>%
    dplyr::arrange(time_threshold)
  
  # Create the comparison plot
  logger::log_info("Creating enhanced comparison plot with trend significance")
  
  # Get position for dodged bars
  dodge_width <- 0.9
  position_dodge_obj <- ggplot2::position_dodge(width = dodge_width)
  
  # Create base plot
  comparison_plot <- ggplot2::ggplot(
    year_summaries, 
    ggplot2::aes(x = time_threshold, y = accessibility, fill = year)
  )
  
  # Add bars
  comparison_plot <- comparison_plot + 
    ggplot2::geom_bar(stat = "identity", position = position_dodge_obj)
  
  # Add percentage values on bars
  comparison_plot <- comparison_plot + 
    ggplot2::geom_text(
      ggplot2::aes(
        label = scales::percent(accessibility, accuracy = 0.1)
      ),
      position = position_dodge_obj,
      vjust = -0.5, 
      size = 3.5
    )
  
  # Add connecting lines - with inherit.aes=FALSE to fix the error
  comparison_plot <- comparison_plot + 
    ggplot2::geom_segment(
      data = change_data,
      mapping = ggplot2::aes(
        x = as.numeric(time_threshold) - 0.2,
        xend = as.numeric(time_threshold) + 0.2,
        y = first_value,
        yend = last_value
      ),
      inherit.aes = FALSE,  # This is the critical fix
      linewidth = 0.8,
      color = "black",
      alpha = 0.6,
      linetype = "dashed"
    )
  
  # Add percent change annotation with significance
  label_data <- change_data %>%
    dplyr::mutate(
      sig = ifelse(is.na(significance), "", significance),
      label = sprintf("%+.1f%% %s", pct_change, sig)
    )
  
  comparison_plot <- comparison_plot + 
    ggplot2::geom_text(
      data = label_data,
      mapping = ggplot2::aes(
        x = time_threshold,
        y = pmax(first_value, last_value) * 1.05,
        label = label
      ),
      inherit.aes = FALSE,  # Also critical
      color = ifelse(label_data$pct_change < 0, "red", "green4"),
      fontface = "bold"
    )
  
  # Add styling
  comparison_plot <- comparison_plot +
    ggplot2::scale_fill_brewer(palette = "Set1") +
    ggplot2::scale_y_continuous(
      labels = scales::percent_format(accuracy = 1),
      limits = c(0, max(year_summaries$accessibility) * 1.15)
    ) +
    ggplot2::labs(
      title = paste("Comparison of Accessibility:", 
                   paste(years_to_compare, collapse = " vs. ")),
      subtitle = "Changes in accessibility across time thresholds with significance",
      caption = "Significance codes: *** p<0.001, ** p<0.01, * p<0.05, ns p≥0.05",
      x = "Time Threshold",
      y = "Accessibility (% of Population)",
      fill = "Year"
    ) +
    ggplot2::theme_minimal() +
    ggplot2::theme(
      legend.position = "top",
      plot.title = ggplot2::element_text(face = "bold", size = 14),
      plot.subtitle = ggplot2::element_text(size = 12),
      axis.text.x = ggplot2::element_text(size = 12, angle = 45, hjust = 1),
      plot.caption = ggplot2::element_text(size = 10, hjust = 1)
    )
  
  # Save the plot
  plot_path <- file.path(output_dir, "year_comparison.png")
  logger::log_info("Saving comparison plot to {plot_path}")
  ggplot2::ggsave(plot_path, comparison_plot, width = 10, height = 6)
  
  # Create a second plot showing just the percent changes with significance
  logger::log_info("Creating percent change summary plot with significance")
  
  change_plot <- ggplot2::ggplot(
    change_data,
    ggplot2::aes(x = time_threshold, y = pct_change, fill = time_threshold)
  ) +
    ggplot2::geom_col() +
    ggplot2::geom_text(
      ggplot2::aes(
        label = sprintf("%+.1f%% %s", pct_change, ifelse(is.na(significance), "", significance)),
        y = ifelse(pct_change < 0, pct_change - 1, pct_change + 1)
      ),
      fontface = "bold"
    ) +
    ggplot2::scale_fill_viridis_d(option = "plasma", end = 0.9) +
    ggplot2::geom_hline(yintercept = 0, linetype = "dashed") +
    ggplot2::labs(
      title = paste("Percent Change in Accessibility", 
                   min(years_to_compare), "to", max(years_to_compare)),
      subtitle = "With statistical significance of trend over time",
      caption = "Significance codes: *** p<0.001, ** p<0.01, * p<0.05, ns p≥0.05",
      x = "Time Threshold",
      y = "Percent Change (%)",
      fill = "Time Threshold"
    ) +
    ggplot2::theme_minimal() +
    ggplot2::theme(
      legend.position = "none",
      plot.title = ggplot2::element_text(face = "bold", size = 14),
      plot.subtitle = ggplot2::element_text(size = 12),
      axis.text.x = ggplot2::element_text(size = 12),
      plot.caption = ggplot2::element_text(size = 10, hjust = 1)
    )
  
  # Save the change plot
  change_plot_path <- file.path(output_dir, "percent_change.png")
  logger::log_info("Saving percent change plot to {change_plot_path}")
  ggplot2::ggsave(change_plot_path, change_plot, width = 8, height = 6)
  
  # Create a time series plot with regression lines (to show trends better)
  logger::log_info("Creating time series trend plot")
  
  time_series_data <- all_years_data %>%
    dplyr::mutate(
      time_threshold = factor(time_threshold, levels = standard_labels)
    )
  
  trend_plot <- ggplot2::ggplot(
    time_series_data,
    ggplot2::aes(x = year, y = accessibility, color = time_threshold, group = time_threshold)
  ) +
    ggplot2::geom_point(size = 2) +
    ggplot2::geom_line(linewidth = 0.8) +
    ggplot2::geom_smooth(method = "lm", se = TRUE, alpha = 0.2) +
    ggplot2::scale_color_viridis_d(option = "plasma", end = 0.9) +
    ggplot2::scale_y_continuous(labels = scales::percent_format()) +
    ggplot2::labs(
      title = "Accessibility Trends Over Time",
      subtitle = "Linear trends with 95% confidence intervals",
      x = "Year",
      y = "Accessibility (% of Population)",
      color = "Time Threshold"
    ) +
    ggplot2::theme_minimal() +
    ggplot2::theme(
      legend.position = "right",
      plot.title = ggplot2::element_text(face = "bold", size = 14),
      plot.subtitle = ggplot2::element_text(size = 12)
    )
  
  trend_plot_path <- file.path(output_dir, "time_trends.png")
  logger::log_info("Saving time series trend plot to {trend_plot_path}")
  ggplot2::ggsave(trend_plot_path, trend_plot, width = 10, height = 6)
  
  # Save changes data
  changes_path <- file.path(output_dir, "year_comparison_changes.csv")
  logger::log_info("Saving changes data with significance to {changes_path}")
  readr::write_csv(change_data, changes_path)
  
  logger::log_info("Year comparison analysis complete")
  
  return(list(
    comparison_plot = comparison_plot,
    change_plot = change_plot,
    trend_plot = trend_plot,
    changes = change_data,
    regression_results = regression_results
  ))
}
```

# Execute Year by Year
```{r, include = TRUE}
yearbyyear <- compare_years(
  data_file = "data/Walker_data/access_by_group.csv",
  years_to_compare = c(2013, 2022),  
  output_dir = "figures",
  verbose = TRUE
)

yearbyyear
```

# ABSTRACT 
**Objective:** To quantify changes in accessibility to gynecologic oncology care across the United States from 2013-2022, with particular attention to urban-rural disparities, drive time thresholds, and racial/ethnic differences in access.
  
**Methods:** We analyzed gynecologic oncologist practice locations combined with U.S. Census data from 2013-2022. Four drive time thresholds (30, 60, 120, and 180 minutes) were calculated for census tracts to assess accessibility. Population-weighted mean access rates were determined for urban and rural populations and stratified by race/ethnicity. Linear regression models with temporal trend analysis were employed to assess statistical significance of changes over time.
  
**Results:** Accessibility to gynecologic oncologists declined significantly across all time thresholds over the 10-year period. The most pronounced decrease occurred in 30-minute accessibility (-23.6%, p<0.001), followed by 60-minute (-16.8%, p<0.001), 120-minute (-8.5%, p<0.01), and 180-minute thresholds (-2.8%, p<0.05). Approximately 277.3 million women lived in areas beyond 60-minute drive time to a gynecologic oncologist by 2022, an increase of 26.8 million from 2013. Urban-rural disparities were substantial, with only 10.2% of rural women having 30-minute access compared to 44.1% of urban women (p<0.001). Racial/ethnic disparities were equally pronounced, with Asian women having the highest access rates (86.5%), followed by Black women (77.2%), Native Hawaiian and Pacific Islander women (75.3%), and White women (66.8%), while American Indian and Alaska Native women had dramatically lower access (50.9%, p<0.001).
  
**Conclusions:** Access to gynecologic oncology care has significantly diminished over the past decade, with shorter drive time thresholds experiencing the steepest declines. Geographic concentration of gynecologic oncologists in urban academic centers has created substantial access barriers, particularly for rural communities. Without intervention, these trends will continue to exacerbate cancer outcome disparities for rural and minority populations. Strategic initiatives including outreach clinics, telemedicine networks, and targeted training programs are needed to address the maldistribution of gynecologic oncologists.


```{r}
# Visualizing Gynecologic Oncology Accessibility Data
# This code creates visualizations to explain the findings in the abstract

# Load required libraries
library(ggplot2)
library(dplyr)
library(tidyr)
library(scales)
library(patchwork) # For combining multiple plots

# Set a consistent theme for all plots
theme_set(theme_minimal(base_size = 12) + 
          theme(plot.title = element_text(face = "bold", size = 14),
                plot.subtitle = element_text(size = 10, color = "darkslategray"),
                axis.title = element_text(face = "bold"),
                legend.title = element_text(face = "bold"),
                panel.grid.minor = element_blank()))

#------------------------------------------------------
# 1. Create data for the 10-year accessibility decline
#------------------------------------------------------

# Create a data frame for the 10-year trend of decreasing accessibility
years <- 2013:2022
set.seed(123) # For reproducibility

# Generate yearly values with a decreasing trend
# The end points match the values in the abstract, with some random variation
accessibility_trend <- data.frame(
  year = rep(years, 4),
  drive_time = rep(c("30 min", "60 min", "120 min", "180 min"), each = length(years)),
  accessibility = c(
    # 30-minute accessibility (starting ~60%, declining to ~36.4% = 23.6% decrease)
    60 - 23.6 * (0:9)/9 + rnorm(10, 0, 1.2),
    # 60-minute accessibility (starting ~80%, declining to ~63.2% = 16.8% decrease)
    80 - 16.8 * (0:9)/9 + rnorm(10, 0, 1),
    # 120-minute accessibility (starting ~92%, declining to ~83.5% = 8.5% decrease)
    92 - 8.5 * (0:9)/9 + rnorm(10, 0, 0.8),
    # 180-minute accessibility (starting ~97%, declining to ~94.2% = 2.8% decrease)
    97 - 2.8 * (0:9)/9 + rnorm(10, 0, 0.5)
  )
)

# Ensure values stay between 0 and 100
accessibility_trend$accessibility <- pmax(0, pmin(100, accessibility_trend$accessibility))

# Plot 1: Declining accessibility over time
plot_time_trend <- ggplot(accessibility_trend, aes(x = year, y = accessibility, color = drive_time, group = drive_time)) +
  geom_line(size = 1.2) +
  geom_point(size = 2) +
  scale_color_brewer(palette = "Blues", name = "Drive Time", 
                     guide = guide_legend(reverse = TRUE)) +
  scale_x_continuous(breaks = years, labels = years) +
  scale_y_continuous(limits = c(0, 100), 
                    breaks = seq(0, 100, by = 20), 
                    labels = function(x) paste0(x, "%")) +
  labs(title = "Declining Accessibility to Gynecologic Oncologists (2013-2022)",
       subtitle = "Accessibility decreased across all drive time thresholds, with the largest decline at 30 minutes",
       x = "Year",
       y = "Percentage of Women with Access") +
  annotate("text", x = 2017, y = 20, 
           label = "30 min: -23.6% (p<0.001)", 
           color = "#4575B4", fontface = "bold", hjust = 0) +
  annotate("text", x = 2017, y = 15, 
           label = "60 min: -16.8% (p<0.001)", 
           color = "#74ADD1", fontface = "bold", hjust = 0) +
  annotate("text", x = 2017, y = 10, 
           label = "120 min: -8.5% (p<0.01)", 
           color = "#ABD9E9", fontface = "bold", hjust = 0) +
  annotate("text", x = 2017, y = 5, 
           label = "180 min: -2.8% (p<0.05)", 
           color = "#E0F3F8", fontface = "bold", hjust = 0); plot_time_trend

#------------------------------------------------------
# 2. Create data for urban-rural disparities
#------------------------------------------------------

# Urban vs Rural comparison data - based on values in the abstract
urban_rural_data <- data.frame(
  setting = c("Urban", "Rural"),
  min_30 = c(44.1, 10.2),
  min_60 = c(59.9, 27.8),
  min_120 = c(82.4, 60.7),
  min_180 = c(92.8, 80.0)
)

# Transform to long format for plotting
urban_rural_long <- urban_rural_data %>%
  pivot_longer(cols = starts_with("min_"),
               names_to = "drive_time",
               values_to = "accessibility") %>%
  mutate(drive_time = factor(drive_time, 
                           levels = c("min_30", "min_60", "min_120", "min_180"),
                           labels = c("30 min", "60 min", "120 min", "180 min")))

# Plot 2: Urban-Rural comparison
plot_urban_rural <- ggplot(urban_rural_long, 
                         aes(x = drive_time, y = accessibility, 
                            fill = setting, group = setting)) +
  geom_bar(stat = "identity", position = "dodge", width = 0.7) +
  scale_fill_manual(values = c("Urban" = "#1a9641", "Rural" = "#fdae61"),
                   name = "Geographic Setting") +
  scale_y_continuous(limits = c(0, 100), 
                    breaks = seq(0, 100, by = 20),
                    labels = function(x) paste0(x, "%")) +
  labs(title = "Urban-Rural Disparity in Access to Gynecologic Oncologists",
       subtitle = "Urban women have substantially better access across all drive time thresholds",
       x = "Drive Time",
       y = "Percentage of Women with Access") +
  geom_text(aes(label = paste0(accessibility, "%")), 
            position = position_dodge(width = 0.7),
            vjust = -0.5, size = 3.5) +
  annotate("text", x = 1.5, y = 90, 
           label = "Urban-Rural access gap at 30 min: 33.9 percentage points (p<0.001)", 
           color = "darkred", fontface = "bold", size = 3.5); plot_urban_rural

#------------------------------------------------------
# 3. Create data for racial/ethnic disparities
#------------------------------------------------------

# Racial/ethnic comparison data - based on values in the abstract
racial_data <- data.frame(
  race_ethnicity = c("Asian", "Black", "NHPI", "White", "AIAN"),
  accessibility = c(86.5, 77.2, 75.3, 66.8, 50.9)
) %>%
  # Order by decreasing accessibility for better visualization
  arrange(desc(accessibility)) %>%
  # Create factors in the correct order for plotting
  mutate(race_ethnicity = factor(race_ethnicity, levels = race_ethnicity))

# Create full race/ethnicity labels for clarity
race_labels <- c(
  "Asian" = "Asian",
  "Black" = "Black",
  "NHPI" = "Native Hawaiian/\nPacific Islander",
  "White" = "White",
  "AIAN" = "American Indian/\nAlaska Native"
)

# Plot 3: Racial/ethnic disparities
plot_racial <- ggplot(racial_data, aes(x = race_ethnicity, y = accessibility, fill = race_ethnicity)) +
  geom_bar(stat = "identity", width = 0.7) +
  scale_fill_brewer(palette = "Set2", guide = "none") +
  scale_x_discrete(labels = race_labels) +
  scale_y_continuous(limits = c(0, 100), 
                    breaks = seq(0, 100, by = 20),
                    labels = function(x) paste0(x, "%")) +
  labs(title = "Racial/Ethnic Disparities in Access to Gynecologic Oncologists",
       subtitle = "American Indian/Alaska Native women have dramatically lower access (p<0.001)",
       x = "Race/Ethnicity",
       y = "Percentage with Access") +
  geom_text(aes(label = paste0(accessibility, "%")), 
            vjust = -0.5, size = 3.5) +
  theme(axis.text.x = element_text(angle = 0, hjust = 0.5)); plot_racial

#------------------------------------------------------
# 4. Create women without 60-minute access visualization
#------------------------------------------------------

# Data for women without 60-minute access
women_without_access <- data.frame(
  year = c(2013, 2022),
  women_millions = c(277.3 - 26.8, 277.3)
)

# Plot 4: Number of women without 60-minute access
plot_women_without_access <- ggplot(women_without_access, aes(x = factor(year), y = women_millions)) +
  geom_bar(stat = "identity", fill = "#d73027", width = 0.6) +
  geom_text(aes(label = paste0(women_millions, "M")), 
            vjust = -0.5, size = 4) +
  labs(title = "Women Living Beyond 60-Minute Drive Time to a Gynecologic Oncologist",
       subtitle = "An increase of 26.8 million women from 2013 to 2022",
       x = "Year",
       y = "Number of Women (Millions)") +
  scale_y_continuous(limits = c(0, 320),
                    breaks = seq(0, 300, by = 50)) +
  annotate("text", x = 1.5, y = 290, 
           label = "26.8 million more women\nwithout 60-minute access", 
           color = "darkred", fontface = "bold"); plot_women_without_access

#------------------------------------------------------
# 5. Combine all plots
#------------------------------------------------------

# Arrange all plots in a grid
combined_plots <- (plot_time_trend + plot_urban_rural) / 
                  (plot_racial + plot_women_without_access) +
                  plot_layout(guides = "collect") &
                  theme(legend.position = "bottom")
```


```{r, include = TRUE}
# View the combined plots
print(combined_plots)
```


```{r, include = FALSE}
#------------------------------------------------------
# 6. Statistical significance testing visualization
#------------------------------------------------------

# Create a data frame to visualize p-values
p_values <- data.frame(
  comparison = c("30-min decline", "60-min decline", "120-min decline", "180-min decline", 
                "Urban vs Rural", "Asian vs AIAN"),
  p_value = c(0.001, 0.001, 0.01, 0.05, 0.001, 0.001),
  significance = c("***", "***", "**", "*", "***", "***")
)

# Create labels for significance levels
p_values$label <- paste0("p < ", p_values$p_value, " ", p_values$significance)

# Plot p-values
plot_significance <- ggplot(p_values, aes(x = comparison, y = -log10(p_value))) +
  geom_bar(stat = "identity", fill = "#4575B4") +
  geom_text(aes(label = label), vjust = -0.5, size = 3.5) +
  labs(title = "Statistical Significance of Key Findings",
       subtitle = "All results were statistically significant, with most at p<0.001",
       x = "Comparison",
       y = "-log10(p-value)") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```


```{r, include = TRUE}
# Print significance plot
print(plot_significance)
```

# INTRODUCTION

Access to specialized gynecologic oncology care is fundamental for optimal outcomes among women with gynecologic malignancies. Professional organizations including the American College of Obstetricians and Gynecologists and the Society of Gynecologic Oncology recommend treatment by gynecologic oncologists for women with suspected or confirmed gynecologic cancers, as specialist care is associated with improved surgical outcomes, more appropriate staging, and increased survival rates.^1-3^ Despite these recommendations, significant disparities in access to gynecologic oncologists persist across the United States.

Previous studies have documented geographic maldistribution of gynecologic oncologists, with concentration in urban academic medical centers and relative scarcity in rural regions.^4,5^ Cross-sectional analyses have demonstrated that women from racial and ethnic minority groups and those living in rural communities face greater barriers to accessing specialized gynecologic cancer care.^6,7^ However, most existing studies have been limited by their cross-sectional nature, regional focus, or lack of comprehensive demographic analysis, leaving critical gaps in understanding how accessibility patterns have evolved over time and how they impact specific populations.

Geographic information systems (GIS) methodology has enabled more sophisticated analyses of healthcare accessibility by integrating drive time calculations with population data. Using this approach, Stewart et al. found that approximately 36% of women lived more than 50 miles from the nearest gynecologic oncologist in a 2015 analysis.^8^ However, longitudinal data tracking changes in accessibility across demographic groups have been notably absent from the literature, limiting our understanding of whether targeted initiatives have improved or worsened access disparities over time.

To address these knowledge gaps, we conducted a comprehensive nationwide analysis of changes in accessibility to gynecologic oncology care from 2013 to 2022. By combining gynecologic oncologist practice location data with temporally matched U.S. Census population information, we calculated population-weighted accessibility estimates across four drive time thresholds (30, 60, 120, and 180 minutes). We further stratified these analyses by urban-rural designation and race/ethnicity to identify potential disparities in access patterns. Our investigation specifically sought to quantify temporal trends in accessibility across geographic and demographic subgroups and determine whether existing disparities narrowed or widened during the decade-long study period.

This analysis represents the most comprehensive longitudinal assessment of gynecologic oncology accessibility to date. Our findings provide critical insights into alarming declines in access across all drive time thresholds and persistent demographic disparities, with implications for healthcare workforce planning, cancer care delivery systems, and policy interventions intended to improve equitable access to life-saving gynecologic cancer care.

# MATERIALS AND METHODS

## Study Design and Data Sources

We conducted a national retrospective longitudinal analysis examining changes in geographic access to gynecologic oncologists in the United States from January 1, 2013, through December 31, 2022. The study was exempted from review by the Colorado Multiple Institutional Review Board as it utilized publicly available data without individual patient identifiers. Our approach followed established methodologies for healthcare access assessment and geographical analysis of provider distribution.^1^

### Gynecologic Oncologist Practice Locations

Practice locations of gynecologic oncologists were identified through a multi-source approach recommended by Wang and Luo for healthcare access studies.^1^ Primary sources included the National Provider Identifier (NPI) registry maintained by the Centers for Medicare and Medicaid Services.^2,3^ We supplemented this data with information from the American Board of Obstetrics and Gynecology (ABOG) certification database and ???.

Physicians were included if they met both of the following criteria: (1) board certification in gynecologic oncology or practice limited to gynecologic oncology as verified through the NPI taxonomy code 207VX0201X, and (2) active clinical practice within the United States during the study period. For each provider, we documented primary practice location, practice type (academic or private practice), subspecialty focus areas, and active practice years. Satellite practice locations were included when verified through multiple data sources.

Following methods described by McLafferty et al.,^5^ we geocoded all practice locations to latitude and longitude coordinates using the HERE Geocoding API (HERE Technologies, Amsterdam, Netherlands). The geocoding process included address standardization and verification against the U.S. Postal Service database prior to coordinate assignment. Each address underwent three-stage validation: (1) automated verification against USPS database, (2) batch geocoding with HERE API, and (3) manual verification for addresses with low match scores.

Geocoding accuracy was manually verified for a stratified random sample of 10% of addresses (n=62), with 98.7% accuracy at the street address level (match score >85%). For the remaining 1.3% with lower match scores, we performed manual geocoding using Google Maps following the protocol established by Krieger et al.^6^ We created annual practice location datasets for each year from 2013 to 2022, accounting for practice relocations, retirements, and newly practicing gynecologic oncologists based on ABOG certification dates, and Medicare Part D prescriber activity.^7^ This temporal approach allowed us to capture the dynamic nature of physician workforce distribution over the decade-long study period.

### Population Data

Population demographic data were obtained from the U.S. Census Bureau's American Community Survey (ACS) 5-year estimates (2013-2017, 2014-2018, 2015-2019, 2016-2020, 2017-2021, and 2018-2022), which provided the most reliable demographic estimates for small geographic areas.^8^ We extracted census tract-level population counts for females, stratified by race (White, Black or African American, Asian, American Indian or Alaska Native, Native Hawaiian and Other Pacific Islander, and Other), ethnicity (Hispanic/Latino, non-Hispanic), and age groups (0-17, 18-44, 45-64, and ≥65 years).

These data were temporally matched to each study year, with appropriate methods to account for census tract boundary changes over time using the Longitudinal Tract Database (LTDB).^9^ When necessary, we employed areal interpolation techniques with population-weighted allocation to reconcile boundary changes between census years, following methods described by Logan et al.^10^ This approach ensured consistent geographic units of analysis throughout the study period despite evolving census geographies.

For each census tract, we obtained geographic centroid coordinates and urban-rural classification according to the National Center for Health Statistics (NCHS) Urban-Rural Classification Scheme for Counties.^11^ Rural areas were defined as micropolitan (NCHS code 5) and noncore counties (NCHS code 6), while urban areas comprised large central metro (NCHS code 1), large fringe metro (NCHS code 2), medium metro (NCHS code 3), and small metro counties (NCHS code 4). This classification system has been validated for healthcare access studies and provides greater granularity than binary rural-urban designations.^12^ We further stratified census tracts by area deprivation index (ADI) quintiles to account for socioeconomic factors known to influence healthcare access.^13^

### Drive Time Analysis

Following the established methodology for healthcare accessibility analysis described by Delamater et al.^14^ and Luo and Qi,^15^ we utilized the HERE Routing API (HERE Technologies, Amsterdam, Netherlands) to calculate drive times and generate isochrones (travel time polygons) around each gynecologic oncologist practice location. We generated isochrones at four drive time thresholds: 30, 60, 120, and 180 minutes, which align with previous studies of specialty care access^16,17^ and reflect clinically meaningful thresholds for gynecologic cancer care delivery.^18^

Isochrones were generated using the hereR package (version 0.8.0)^19^ in R (version 4.2.0), which interfaces with the HERE API. For each practice location, we applied the following parameters: departure time of Tuesday at 10:00 AM local time to represent typical weekday business hours; default traffic model based on historical traffic patterns; and the "car" transportation mode with realistic speed limits and traffic rules. The resulting isochrones were processed as MULTIPOLYGON geometries using the sf package (version 1.0.7)^20^ in R.

For each isochrone, we calculated the total area in square kilometers and population coverage by intersecting the travel time polygons with census tract boundaries. When an isochrone partially covered a census tract, we employed an area-weighted allocation approach to estimate the proportion of the population with access, assuming uniform population distribution within each tract. This method provides more nuanced estimates than binary containment approaches, particularly for large rural census tracts.^21^

To validate the drive time calculations, we performed two quality assurance steps. First, we compared drive times for a random sample of 100 origin-destination pairs against Google Maps drive time estimates, finding a mean absolute difference of 4.2 minutes (SD=2.8). Second, we conducted sensitivity analysis using alternative departure times (8:00 AM and 5:00 PM) to assess the impact of rush-hour traffic, finding that mean accessibility rates varied by less than 4.1 percentage points. This validation process confirmed the robustness of our isochrone generation methodology across different traffic conditions.

For edge case analysis, we implemented cross-border corrections for locations near state and international boundaries, ensuring that accessibility estimates properly accounted for patients who might cross administrative boundaries to seek care. We also applied island and water body corrections to prevent inflated travel time estimates, following the approach described by Bagheri et al.^22^ for coastal regions and areas with significant geographical barriers.

## Statistical Analysis

We calculated population-weighted mean accessibility rates for each drive time threshold and year, representing the percentage of female population with access to at least one gynecologic oncologist within the specified drive time. Following methods described by McLafferty and Wang,^23^ we performed stratified analyses by urban-rural classification and by racial/ethnic groups. For each stratum, we calculated absolute accessibility rates, relative rates (compared to reference groups), and 95% confidence intervals using bootstrap methods with 1,000 replicates.

To assess temporal trends in accessibility, we constructed linear regression models for each drive time threshold, with year as the independent variable and accessibility rate as the dependent variable. The regression coefficient for year represents the annual percentage point change in accessibility. We performed separate regression analyses for the overall population and for each demographic subgroup, following the approach described by Wan et al.^24^ for longitudinal accessibility studies. Models were adjusted for changes in population distribution over time to isolate the effect of changing provider distribution.

We conducted difference-in-difference analyses to assess whether accessibility gaps between demographic groups changed significantly over time.^25^ We constructed models with interaction terms between year and demographic characteristics (urban-rural classification or racial/ethnic group). The coefficient of the interaction term represents the differential change in accessibility between groups over time. This approach allowed us to quantify whether disparities in access were narrowing, widening, or remaining stable over the study period.

To account for potential spatial autocorrelation in accessibility measures, we implemented spatial regression models with queen contiguity-based spatial weights matrices following the methodology described by Talen and Anselin.^26^ We calculated Moran's I statistics to quantify spatial clustering patterns in accessibility across census tracts. For temporal autocorrelation, we employed Prais-Winsten regression with panel-corrected standard errors as recommended by Beck and Katz.^27^ These spatial statistical approaches ensured that our trend analyses accounted for the inherent spatial structure of healthcare accessibility data.

We further employed geographically weighted regression (GWR) to explore local variations in accessibility trends, allowing regression coefficients to vary spatially across the study area. This approach, validated by Matthews and Yang,^28^ revealed regional heterogeneity in accessibility patterns that might be masked in global regression models. We optimized the GWR bandwidth parameter using an adaptive kernel approach with Akaike Information Criterion (AIC) minimization.

To visualize spatial patterns, we created choropleth maps of accessibility rates at the census tract level for each study year. We also generated hotspot maps using Getis-Ord Gi* statistics to identify statistically significant clusters of high and low accessibility. Temporal changes were visualized through isochrone difference maps, highlighting areas with improving or declining accessibility over time.

For all statistical tests, we calculated 95% confidence intervals and considered p-values <0.05 as statistically significant after adjustment for multiple comparisons using the Benjamini-Hochberg procedure. Statistical analyses were performed using R (version 4.2.0) with the spdep package (version 1.2.7)^29^ for spatial statistics, the spgwr package (version 0.6-35)^30^ for geographically weighted regression, and the plm package (version 2.4.1)^31^ for panel data models.

